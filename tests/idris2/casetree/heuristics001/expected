1/1: Building Main (Main.idr)
Main> Main.mergeLim
Arguments [{arg:0}, {arg:1}, {arg:2}, {arg:3}]
Compile time tree: case {arg:3} of
  Z => {arg:1}
  _ => case {arg:1} of
    Nil {e:9} => case {arg:3} of
      S {e:10} => {arg:2}
      _ => case {arg:2} of
        Nil {e:7} => case {arg:3} of
          S {e:8} => {arg:1}
          _ => case {arg:1} of
            (::) {e:0} {e:1} {e:2} => case {arg:2} of
              (::) {e:3} {e:4} {e:5} => case {arg:3} of
                S {e:6} => {e:1} :: mergeLim {e:2} ({e:4} :: {e:5}) {e:6}
        _ => case {arg:1} of
          (::) {e:0} {e:1} {e:2} => case {arg:2} of
            (::) {e:3} {e:4} {e:5} => case {arg:3} of
              S {e:6} => {e:1} :: mergeLim {e:2} ({e:4} :: {e:5}) {e:6}
    _ => case {arg:2} of
      Nil {e:7} => case {arg:3} of
        S {e:8} => {arg:1}
        _ => case {arg:1} of
          (::) {e:0} {e:1} {e:2} => case {arg:2} of
            (::) {e:3} {e:4} {e:5} => case {arg:3} of
              S {e:6} => {e:1} :: mergeLim {e:2} ({e:4} :: {e:5}) {e:6}
      _ => case {arg:1} of
        (::) {e:0} {e:1} {e:2} => case {arg:2} of
          (::) {e:3} {e:4} {e:5} => case {arg:3} of
            S {e:6} => {e:1} :: mergeLim {e:2} ({e:4} :: {e:5}) {e:6}
Erasable args: [0]
Inferrable args: [0]
Compiled: \ {arg:1}, {arg:2}, {arg:3} => case {arg:3} of
  { 0 => {arg:1}
  ; _ => case {arg:1} of
           { _builtin.NIL {tag = 0} [nil] => case {arg:3} of  { 0 => case {arg:2} of  { _builtin.NIL {tag = 0} [nil] => case {arg:3} of  { 0 => case {arg:1} of  { _builtin.CONS {tag = 1} [cons] {e:1} {e:2} => case {arg:2} of  { _builtin.CONS {tag = 1} [cons] {e:4} {e:5} => case {arg:3} of  { 0 => crash "Nat case not covered"; _ => let {e:6} = {arg:3} - 1 in_builtin.CONS {tag = 1} [cons] {e:1} (Main.mergeLim {e:2} (_builtin.CONS {tag = 1} [cons] {e:4} {e:5}) {e:6})}}}; _ => {arg:1}}; _ => case {arg:1} of  { _builtin.CONS {tag = 1} [cons] {e:1} {e:2} => case {arg:2} of  { _builtin.CONS {tag = 1} [cons] {e:4} {e:5} => case {arg:3} of  { 0 => crash "Nat case not covered"; _ => let {e:6} = {arg:3} - 1 in_builtin.CONS {tag = 1} [cons] {e:1} (Main.mergeLim {e:2} (_builtin.CONS {tag = 1} [cons] {e:4} {e:5}) {e:6})}}}}; _ => {arg:2}}
           ; _ => case {arg:2} of
                    { _builtin.NIL {tag = 0} [nil] => case {arg:3} of  { 0 => case {arg:1} of  { _builtin.CONS {tag = 1} [cons] {e:1} {e:2} => case {arg:2} of  { _builtin.CONS {tag = 1} [cons] {e:4} {e:5} => case {arg:3} of  { 0 => crash "Nat case not covered"; _ => let {e:6} = {arg:3} - 1 in_builtin.CONS {tag = 1} [cons] {e:1} (Main.mergeLim {e:2} (_builtin.CONS {tag = 1} [cons] {e:4} {e:5}) {e:6})}}}; _ => {arg:1}}
                    ; _ => case {arg:1} of
                             { _builtin.CONS {tag = 1} [cons] {e:1} {e:2} => case {arg:2} of  { _builtin.CONS {tag = 1} [cons] {e:4} {e:5} => case {arg:3} of  { 0 => crash "Nat case not covered"; _ => let {e:6} = {arg:3} - 1 in_builtin.CONS {tag = 1} [cons] {e:1} (Main.mergeLim {e:2} (_builtin.CONS {tag = 1} [cons] {e:4} {e:5}) {e:6})}}
                             }
                    }
           }
  }
Refers to: Main.mergeLim, Prelude.Basics.(::)
Refers to (runtime): _builtin.CONS, _builtin.NIL, Main.mergeLim
Flags: covering
Size change:
  Prelude.Basics.(::):
    l 0 1 2
  r +------
  0 | = < <
  1 |   <
  Main.mergeLim:
    l 0 1 2 3
  r +--------
  0 | = < <
  1 |   <
  2 |     =
  3 |       <
Main> 
Bye for now!
------
1/1: Building Main (Main.idr)
Main> Main.mergeLim
Arguments [{arg:0}, {arg:1}, {arg:2}, {arg:3}]
Compile time tree: case {arg:3} of
  Z => {arg:1}
  _ => case {arg:1} of
    Nil {e:9} => case {arg:3} of
      S {e:10} => {arg:2}
      _ => case {arg:2} of
        Nil {e:7} => case {arg:3} of
          S {e:8} => {arg:1}
          _ => case {arg:1} of
            (::) {e:0} {e:1} {e:2} => case {arg:2} of
              (::) {e:3} {e:4} {e:5} => case {arg:3} of
                S {e:6} => {e:1} :: mergeLim {e:2} ({e:4} :: {e:5}) {e:6}
        _ => case {arg:1} of
          (::) {e:0} {e:1} {e:2} => case {arg:2} of
            (::) {e:3} {e:4} {e:5} => case {arg:3} of
              S {e:6} => {e:1} :: mergeLim {e:2} ({e:4} :: {e:5}) {e:6}
    _ => case {arg:2} of
      Nil {e:7} => case {arg:3} of
        S {e:8} => {arg:1}
        _ => case {arg:1} of
          (::) {e:0} {e:1} {e:2} => case {arg:2} of
            (::) {e:3} {e:4} {e:5} => case {arg:3} of
              S {e:6} => {e:1} :: mergeLim {e:2} ({e:4} :: {e:5}) {e:6}
      _ => case {arg:1} of
        (::) {e:0} {e:1} {e:2} => case {arg:2} of
          (::) {e:3} {e:4} {e:5} => case {arg:3} of
            S {e:6} => {e:1} :: mergeLim {e:2} ({e:4} :: {e:5}) {e:6}
Erasable args: [0]
Inferrable args: [0]
Compiled: \ {arg:1}, {arg:2}, {arg:3} => case {arg:3} of
  { 0 => {arg:1}
  ; _ => let {e:0} = {arg:3} - 1 in
         case {arg:1} of
           { _builtin.NIL {tag = 0} [nil] => {arg:2}
           ; _ => case {arg:2} of
                    { _builtin.NIL {tag = 0} [nil] => {arg:1}
                    ; _ => case {arg:1} of
                             { _builtin.CONS {tag = 1} [cons] {e:2} {e:3} => case {arg:2} of  { _builtin.CONS {tag = 1} [cons] {e:5} {e:6} => _builtin.CONS {tag = 1} [cons] {e:2} (Main.mergeLim {e:3} (_builtin.CONS {tag = 1} [cons] {e:5} {e:6}) {e:0})}
                             }
                    }
           }
  }
Refers to: Main.mergeLim, Prelude.Basics.(::)
Refers to (runtime): _builtin.CONS, _builtin.NIL, Main.mergeLim
Flags: covering
Size change:
  Prelude.Basics.(::):
    l 0 1 2
  r +------
  0 | = < <
  1 |   <
  Main.mergeLim:
    l 0 1 2 3
  r +--------
  0 | = < <
  1 |   <
  2 |     =
  3 |       <
Main> 
Bye for now!
