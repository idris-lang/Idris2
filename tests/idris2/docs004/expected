1/1: Building DocImpl (DocImpl.idr)
Main> interface Main.Happy : Type -> Type
  Parameters: t
  Methods:
    happy : t
  Implementations:
    Happy Nat
    Happy Bool
Main> happy : Bool
happy = True
Main> happy : Nat
happy = 0
Main> show : String -> String
show cs = strCons '"' (showLitString (unpack cs) """)

showPrec : Prec -> String -> String
showPrec _ x = show x
Main> (==) : Eq a => List a -> List a -> Bool
[] == [] = True
(x :: xs) == (y :: ys) = (x == y) && Delay (xs == ys)
_ == _ = False

(/=) : Eq a => List a -> List a -> Bool
x /= y = not (x == y)
Main> map : (a -> b) -> Maybe a -> Maybe b
map f (Just x) = Just (f x)
map f Nothing = Nothing
Main> foldr : (elem -> acc -> acc) -> acc -> Either e elem -> acc
foldr f acc (Left _) = acc
foldr f acc (Right x) = f x acc

foldl : (acc -> elem -> acc) -> acc -> Either e elem -> acc
foldl f z t = foldr (flip . . flip f) id t z

null : Either e elem -> Bool
null (Left _) = True
null (Right _) = False

foldlM : Monad m => (acc -> elem -> m acc) -> acc -> Either e elem -> m acc
foldlM fm a0 = foldl (\ma, b => ma >>= flip fm b) (pure a0)

toList : Either e elem -> List elem
toList = foldr :: []

foldMap : Monoid m => (a -> m) -> Either e a -> m
foldMap f = foldr (<+> . f) neutral
Main> Bye for now!
