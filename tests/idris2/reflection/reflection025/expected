1/1: Building RefDefs (RefDefs.idr)
LOG elab:0: Names `RefDefs.simple` refers to:
LOG elab:0:   - prim__sub_Integer
LOG elab:0:   - prim__lte_Integer
LOG elab:0:   - Prelude.Types.case block in "integerToNat"
LOG elab:0:   - Prelude.Types.fromInteger
LOG elab:0:   - Prelude.Types.Num implementation at Prelude.Types:1
LOG elab:0:   - Prelude.Types.+
LOG elab:0:   - Prelude.Types.*
LOG elab:0:   - Prelude.Types.plus
LOG elab:0:   - Prelude.Types.mult
LOG elab:0:   - Prelude.Types.integerToNat
LOG elab:0:   - Prelude.Types.Z
LOG elab:0:   - Prelude.Types.S
LOG elab:0:   - Prelude.Types.Nat
LOG elab:0:   - Prelude.Num.MkNum
LOG elab:0:   - Prelude.Num.(+)
LOG elab:0:   - Prelude.Basics.intToBool
LOG elab:0:   - Prelude.Basics.True
LOG elab:0:   - Prelude.Basics.False
LOG elab:0:   - Builtin.assert_total
LOG elab:0: 
LOG elab:0: Names `RefDefs.simpleRec` refers to:
LOG elab:0:   - Prelude.Types.Z
LOG elab:0:   - Prelude.Types.S
LOG elab:0:   - RefDefs.simpleRec
LOG elab:0: 
LOG elab:0: Names `RefDefs.mutRec1` refers to:
LOG elab:0:   - Prelude.Types.Z
LOG elab:0:   - RefDefs.mutRec1
LOG elab:0:   - RefDefs.mutRec2
LOG elab:0: 
LOG elab:0: Names `Prelude.Basics.Bool` refers to:
LOG elab:0: 
LOG elab:0: Names `Prelude.Types.Nat` refers to:
LOG elab:0: 
LOG elab:0: Names `Language.Reflection.TTImp.TTImp` refers to:
LOG elab:0: 
------------
1/1: Building CurrFn (CurrFn.idr)
LOG elab:0: current fn: [< ]
LOG elab:0: current fn: [< CurrFn.f]
LOG elab:0: current fn: [< CurrFn.f']
LOG elab:0: current fn: [< CurrFn.f'']
LOG elab:0: current fn: [< CurrFn.f''', CurrFn.case block in "f'''"]
LOG elab:0: current fn: [< CurrFn.n, CurrFn.1:f]
LOG elab:0: current fn: [< CurrFn.w, CurrFn.with block in "w"]
LOG elab:0: current fn: [< CurrFn.w, CurrFn.with block in "w"]
------------
2/2: Building RefDefsDeep (RefDefsDeep.idr)
LOG elab:0: === current fn: [< ] ===
LOG elab:0: === current fn: [< RefDefsDeep.f] ===
LOG elab:0: === current fn: [< RefDefsDeep.f'] ===
LOG elab:0: === current fn: [< RefDefsDeep.f''] ===
LOG elab:0: === current fn: [< RefDefsDeep.f''', RefDefsDeep.case block in "f'''"] ===
LOG elab:0: === current fn: [< RefDefsDeep.n, RefDefsDeep.1:f] ===
LOG elab:0: === current fn: [< RefDefsDeep.w, RefDefsDeep.with block in "w"] ===
LOG elab:0: === current fn: [< RefDefsDeep.w, RefDefsDeep.with block in "w"] ===
LOG elab:0: Names `RefDefsDeep.f` refers to:
LOG elab:0:   - prim__sub_Integer
LOG elab:0:   - prim__lte_Integer
LOG elab:0:   - Prelude.Types.case block in "integerToNat"
LOG elab:0:   - Prelude.Types.fromInteger
LOG elab:0:   - Prelude.Types.Num implementation at Prelude.Types:1
LOG elab:0:   - Prelude.Types.+
LOG elab:0:   - Prelude.Types.*
LOG elab:0:   - Prelude.Types.plus
LOG elab:0:   - Prelude.Types.mult
LOG elab:0:   - Prelude.Types.integerToNat
LOG elab:0:   - Prelude.Types.Z
LOG elab:0:   - Prelude.Types.S
LOG elab:0:   - Prelude.Types.Nat
LOG elab:0:   - Prelude.Num.MkNum
LOG elab:0:   - Prelude.Num.(+)
LOG elab:0:   - Prelude.Basics.intToBool
LOG elab:0:   - Prelude.Basics.True
LOG elab:0:   - Prelude.Basics.False
LOG elab:0:   - Builtin.assert_total
LOG elab:0:   - Builtin.MkUnit
LOG elab:0:   - RefDefsDeep.case block in "f"
LOG elab:0: 
LOG elab:0: Names `RefDefsDeep.f'` refers to:
LOG elab:0:   - prim__sub_Integer
LOG elab:0:   - prim__lte_Integer
LOG elab:0:   - Prelude.Types.case block in "integerToNat"
LOG elab:0:   - Prelude.Types.fromInteger
LOG elab:0:   - Prelude.Types.Num implementation at Prelude.Types:1
LOG elab:0:   - Prelude.Types.+
LOG elab:0:   - Prelude.Types.*
LOG elab:0:   - Prelude.Types.plus
LOG elab:0:   - Prelude.Types.mult
LOG elab:0:   - Prelude.Types.integerToNat
LOG elab:0:   - Prelude.Types.Z
LOG elab:0:   - Prelude.Types.S
LOG elab:0:   - Prelude.Types.Nat
LOG elab:0:   - Prelude.Num.MkNum
LOG elab:0:   - Prelude.Num.(+)
LOG elab:0:   - Prelude.Basics.intToBool
LOG elab:0:   - Prelude.Basics.True
LOG elab:0:   - Prelude.Basics.False
LOG elab:0:   - Builtin.assert_total
LOG elab:0:   - Builtin.MkUnit
LOG elab:0:   - RefDefsDeep.case block in "f'"
LOG elab:0: 
LOG elab:0: Names `RefDefsDeep.f''` refers to:
LOG elab:0:   - prim__sub_Integer
LOG elab:0:   - prim__lte_Integer
LOG elab:0:   - Prelude.Types.case block in "integerToNat"
LOG elab:0:   - Prelude.Types.fromInteger
LOG elab:0:   - Prelude.Types.Num implementation at Prelude.Types:1
LOG elab:0:   - Prelude.Types.+
LOG elab:0:   - Prelude.Types.*
LOG elab:0:   - Prelude.Types.plus
LOG elab:0:   - Prelude.Types.mult
LOG elab:0:   - Prelude.Types.integerToNat
LOG elab:0:   - Prelude.Types.Z
LOG elab:0:   - Prelude.Types.S
LOG elab:0:   - Prelude.Types.Nat
LOG elab:0:   - Prelude.Num.MkNum
LOG elab:0:   - Prelude.Num.(+)
LOG elab:0:   - Prelude.Basics.intToBool
LOG elab:0:   - Prelude.Basics.True
LOG elab:0:   - Prelude.Basics.False
LOG elab:0:   - Builtin.assert_total
LOG elab:0:   - Builtin.MkUnit
LOG elab:0:   - RefDefsDeep.f
LOG elab:0:   - RefDefsDeep.case block in "f"
LOG elab:0:   - RefDefsDeep.case block in "f''"
LOG elab:0: 
LOG elab:0: Names `RefDefsDeep.f'''` refers to:
LOG elab:0:   - prim__sub_Integer
LOG elab:0:   - prim__lte_Integer
LOG elab:0:   - Prelude.Types.case block in "integerToNat"
LOG elab:0:   - Prelude.Types.fromInteger
LOG elab:0:   - Prelude.Types.Num implementation at Prelude.Types:1
LOG elab:0:   - Prelude.Types.+
LOG elab:0:   - Prelude.Types.*
LOG elab:0:   - Prelude.Types.plus
LOG elab:0:   - Prelude.Types.mult
LOG elab:0:   - Prelude.Types.integerToNat
LOG elab:0:   - Prelude.Types.Z
LOG elab:0:   - Prelude.Types.S
LOG elab:0:   - Prelude.Types.Nat
LOG elab:0:   - Prelude.Num.MkNum
LOG elab:0:   - Prelude.Num.(+)
LOG elab:0:   - Prelude.Basics.intToBool
LOG elab:0:   - Prelude.Basics.True
LOG elab:0:   - Prelude.Basics.False
LOG elab:0:   - Builtin.assert_total
LOG elab:0:   - Builtin.MkUnit
LOG elab:0:   - RefDefsDeep.f
LOG elab:0:   - RefDefsDeep.case block in "f"
LOG elab:0:   - RefDefsDeep.case block in "f'''"
LOG elab:0:   - RefDefsDeep.case block in "case block in f'''"
LOG elab:0: 
LOG elab:0: Names `RefDefsDeep.n` refers to:
LOG elab:0:   - prim__sub_Integer
LOG elab:0:   - prim__lte_Integer
LOG elab:0:   - Prelude.Types.case block in "integerToNat"
LOG elab:0:   - Prelude.Types.fromInteger
LOG elab:0:   - Prelude.Types.Num implementation at Prelude.Types:1
LOG elab:0:   - Prelude.Types.+
LOG elab:0:   - Prelude.Types.*
LOG elab:0:   - Prelude.Types.plus
LOG elab:0:   - Prelude.Types.mult
LOG elab:0:   - Prelude.Types.integerToNat
LOG elab:0:   - Prelude.Types.Z
LOG elab:0:   - Prelude.Types.S
LOG elab:0:   - Prelude.Types.Nat
LOG elab:0:   - Prelude.Num.MkNum
LOG elab:0:   - Prelude.Num.(+)
LOG elab:0:   - Prelude.Basics.intToBool
LOG elab:0:   - Prelude.Basics.True
LOG elab:0:   - Prelude.Basics.False
LOG elab:0:   - Builtin.assert_total
LOG elab:0:   - Builtin.MkUnit
LOG elab:0:   - RefDefsDeep.1:f
LOG elab:0:   - RefDefsDeep.case block in "n,f"
LOG elab:0: 
LOG elab:0: Names `RefDefsDeep.w` refers to:
LOG elab:0:   - prim__sub_Integer
LOG elab:0:   - prim__lte_Integer
LOG elab:0:   - Prelude.Types.case block in "integerToNat"
LOG elab:0:   - Prelude.Types.fromInteger
LOG elab:0:   - Prelude.Types.Num implementation at Prelude.Types:1
LOG elab:0:   - Prelude.Types.+
LOG elab:0:   - Prelude.Types.*
LOG elab:0:   - Prelude.Types.plus
LOG elab:0:   - Prelude.Types.mult
LOG elab:0:   - Prelude.Types.integerToNat
LOG elab:0:   - Prelude.Types.Z
LOG elab:0:   - Prelude.Types.S
LOG elab:0:   - Prelude.Types.Nat
LOG elab:0:   - Prelude.Num.MkNum
LOG elab:0:   - Prelude.Num.(+)
LOG elab:0:   - Prelude.Basics.intToBool
LOG elab:0:   - Prelude.Basics.True
LOG elab:0:   - Prelude.Basics.False
LOG elab:0:   - Builtin.assert_total
LOG elab:0:   - Builtin.MkUnit
LOG elab:0:   - RefDefsDeep.f
LOG elab:0:   - RefDefsDeep.case block in "f"
LOG elab:0:   - RefDefsDeep.with block in "w"
LOG elab:0:   - RefDefsDeep.case block in "with block in w"
LOG elab:0:   - RefDefsDeep.case block in "with block in w"
LOG elab:0: 
------------
1/1: Building InspectRec (InspectRec.idr)
LOG elab:0: case zero case: non-recursive
LOG elab:0: case non-zero case: non-recursive
LOG elab:0: case base case: non-recursive
LOG elab:0: case next cast: recursive
LOG elab:0: case mutual rec 1, base: non-recursive
LOG elab:0: case mutual rec 1, next: non-recursive
LOG elab:0: case mutual rec 2, base: non-recursive
LOG elab:0: case mutual rec 2, next: recursive
LOG elab:0: case nestedMut rec 1, base: non-recursive
LOG elab:0: case nestedMut rec 2, base: non-recursive
LOG elab:0: case nestedMut rec 2, next: recursive
LOG elab:0: case nestedMut rec 1, next: recursive
