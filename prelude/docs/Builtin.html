<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Builtin</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Builtin
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Builtin<span style="float:right">(<a href="../source/Builtin.html">source</a>)</span></h1><pre></pre></div><code></code><h2>Definitions</h2><dl class="decls"><dt id="Builtin.assert_total"><code><a class="type" href="Builtin.html#Builtin.assert_total"><span class="name function">assert_total</span></a>&ensp;:&ensp;(<span class="keyword">1</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Assert to the totality checker that the given expression will always<br>  terminate.<br>  <br>  The multiplicity of its argument is 1, so `assert_total` won&apos;t affect how<br>  many times variables are used. If you&apos;re not writing a linear function,<br>  this doesn&apos;t make a difference.<br>  <br>  Note: assert_total can reduce at compile time, if required for unification,<br>  which might mean that it&apos;s no longer guarded a subexpression. Therefore,<br>  it is best to use it around the smallest possible subexpression.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.assert_smaller"><code><a class="type" href="Builtin.html#Builtin.assert_smaller"><span class="name function">assert_smaller</span></a>&ensp;:&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">1</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Assert to the totality checker that y is always structurally smaller than x<br>  (which is typically a pattern argument, and *must* be in normal form for<br>  this to work).<br>  <br>  The multiplicity of x is 0, so in a linear function, you can pass values to<br>  x even if they have already been used.<br>  The multiplicity of y is 1, so `assert_smaller` won&apos;t affect how many times<br>  its y argument is used.<br>  If you&apos;re not writing a linear function, the multiplicities don&apos;t make a<br>  difference.<br>  <br>  @ x the larger value (typically a pattern argument)<br>  @ y the smaller value (typically an argument to a recursive call)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.Unit"><code><span class="keyword">data</span>&ensp;<a class="type" href="Builtin.html#Builtin.Unit"><span class="name type">Unit</span></a>&ensp;:&ensp;<span class="name type">Type</span></code></dt><dd><pre>  The canonical single-element type, also known as the trivially true<br>  proposition.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Builtin.MkUnit"><code><a class="type" href="Builtin.html#Builtin.MkUnit"><span class="name constructor">MkUnit</span></a>&ensp;:&ensp;()</code></dt><dd><pre>  The trivial constructor for `()`.</pre></dd></dl></dd><dt id="Builtin.Pair"><code><span class="keyword">data</span>&ensp;<a class="type" href="Builtin.html#Builtin.Pair"><span class="name type">Pair</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  The non-dependent pair type, also known as conjunction.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Builtin.MkPair"><code><a class="type" href="Builtin.html#Builtin.MkPair"><span class="name constructor">MkPair</span></a>&ensp;:&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>,&ensp;<span class="boundvar">b</span>)</code></dt><dd><pre>  A pair of elements.<br>  @ a the left element of the pair<br>  @ b the right element of the pair</pre></dd></dl></dd><dt id="Builtin.fst"><code><a class="type" href="Builtin.html#Builtin.fst"><span class="name function">fst</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>,&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Return the first element of a pair.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.snd"><code><a class="type" href="Builtin.html#Builtin.snd"><span class="name function">snd</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>,&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Return the second element of a pair.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.swap"><code><a class="type" href="Builtin.html#Builtin.swap"><span class="name function">swap</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>,&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">b</span>,&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Swap the elements in a pair</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.LPair"><code><span class="keyword">data</span>&ensp;<a class="type" href="Builtin.html#Builtin.LPair"><span class="name type">LPair</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A pair type where each component is linear</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Builtin.#"><code><a class="type" href="Builtin.html#Builtin.#"><span class="name constructor">(#)</span></a>&ensp;:&ensp;(<span class="keyword">1</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">1</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Builtin.html#Builtin.LPair"><span class="name type">LPair</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  A linear pair of elements.<br>  If you take one copy of the linear pair apart<br>  then you only get one copy of its left and right elements.<br>  @ a the left element of the pair<br>  @ b the right element of the pair</pre></dd></dl></dd><dt id="Builtin.DPair.DPair"><code><span class="keyword">record</span>&ensp;<span class="type resolved" title="Builtin.DPair.DPair"><span class="name type">DPair</span></span>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Dependent pairs aid in the construction of dependent types by providing<br>  evidence that some value resides in the type.<br>  <br>  Formally, speaking, dependent pairs represent existential quantification -<br>  they consist of a witness for the existential claim and a proof that the<br>  property holds for it.<br>  <br>  @ a the value to place in the type.<br>  @ p the dependent type that requires the value.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Builtin.DPair.MkDPair"><code><span class="type resolved" title="Builtin.DPair.MkDPair"><span class="name constructor">MkDPair</span></span>&ensp;:&ensp;(<span class="boundvar">fst</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">fst</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Builtin.DPair.DPair"><span class="name type">DPair</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">p</span></code></dt></dl><br>  <b>Projections</b>:<br><dl class="decls">  <dt id="Builtin.DPair.DPair.(.fst)"><code><span class="type resolved" title="Builtin.DPair.DPair.(.fst)"><span class="name function">.fst</span></span>&ensp;:&ensp;<span class="type resolved" title="Builtin.DPair.DPair"><span class="name type">DPair</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt>  <dt id="Builtin.DPair.DPair.(.snd)"><code><span class="type resolved" title="Builtin.DPair.DPair.(.snd)"><span class="name function">.snd</span></span>&ensp;:&ensp;(<span class="boundvar">{rec:0}</span>&ensp;:&ensp;<span class="type resolved" title="Builtin.DPair.DPair"><span class="name type">DPair</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">p</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<span class="type resolved" title="Builtin.DPair.DPair.fst"><span class="name function">fst</span></span>&ensp;<span class="boundvar">{rec:0}</span>)</code></dt></dl></dd><dt id="Builtin.DPair.DPair.(.fst)"><code><span class="type resolved" title="Builtin.DPair.DPair.(.fst)"><span class="name function">.fst</span></span>&ensp;:&ensp;<span class="type resolved" title="Builtin.DPair.DPair"><span class="name type">DPair</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.DPair.DPair.fst"><code><span class="type resolved" title="Builtin.DPair.DPair.fst"><span class="name function">fst</span></span>&ensp;:&ensp;<span class="type resolved" title="Builtin.DPair.DPair"><span class="name type">DPair</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.DPair.DPair.(.snd)"><code><span class="type resolved" title="Builtin.DPair.DPair.(.snd)"><span class="name function">.snd</span></span>&ensp;:&ensp;(<span class="boundvar">{rec:0}</span>&ensp;:&ensp;<span class="type resolved" title="Builtin.DPair.DPair"><span class="name type">DPair</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">p</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<span class="type resolved" title="Builtin.DPair.DPair.fst"><span class="name function">fst</span></span>&ensp;<span class="boundvar">{rec:0}</span>)</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.DPair.DPair.snd"><code><span class="type resolved" title="Builtin.DPair.DPair.snd"><span class="name function">snd</span></span>&ensp;:&ensp;(<span class="boundvar">{rec:0}</span>&ensp;:&ensp;<span class="type resolved" title="Builtin.DPair.DPair"><span class="name type">DPair</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">p</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<span class="type resolved" title="Builtin.DPair.DPair.fst"><span class="name function">fst</span></span>&ensp;<span class="boundvar">{rec:0}</span>)</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.DPair.Res"><code><span class="keyword">data</span>&ensp;<span class="type resolved" title="Builtin.DPair.Res"><span class="name type">Res</span></span>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A dependent variant of LPair, pairing a result value with a resource<br>  that depends on the result value</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Builtin.DPair.#"><code><span class="type resolved" title="Builtin.DPair.#"><span class="name constructor">(#)</span></span>&ensp;:&ensp;(<span class="boundvar">val</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">1</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">val</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Builtin.DPair.Res"><span class="name type">Res</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">t</span></code></dt></dl></dd><dt id="Builtin.Void"><code><span class="keyword">data</span>&ensp;<a class="type" href="Builtin.html#Builtin.Void"><span class="name type">Void</span></a>&ensp;:&ensp;<span class="name type">Type</span></code></dt><dd><pre>  The empty type, also known as the trivially false proposition.<br>  <br>  Use `void` or `absurd` to prove anything if you have a variable of type<br>  `Void` in scope.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.Equal"><code><span class="keyword">data</span>&ensp;<a class="type" href="Builtin.html#Builtin.Equal"><span class="name type">Equal</span></a>&ensp;:&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Builtin.Refl"><code><a class="type" href="Builtin.html#Builtin.Refl"><span class="name constructor">Refl</span></a>&ensp;:&ensp;<span class="boundvar">x</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">x</span></code></dt></dl></dd><dt id="Builtin.==="><code><a class="type" href="Builtin.html#Builtin.==="><span class="name function">(===)</span></a>&ensp;:&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Builtin.~=~"><code><a class="type" href="Builtin.html#Builtin.~=~"><span class="name function">(~=~)</span></a>&ensp;:&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Explicit heterogeneous (&quot;John Major&quot;) equality.  Use this when Idris<br>  incorrectly chooses homogeneous equality for `(=)`.<br>  @ a the type of the left side<br>  @ b the type of the right side<br>  @ x the left side<br>  @ y the right side</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;6</dd><dt id="Builtin.rewrite__impl"><code><a class="type" href="Builtin.html#Builtin.rewrite__impl"><span class="name function">rewrite__impl</span></a>&ensp;:&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">p</span>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">x</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">y</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">1</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">y</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Perform substitution in a term according to some equality.<br>  <br>  Like `replace`, but with an explicit predicate, and applying the rewrite in<br>  the other direction, which puts it in a form usable by the `rewrite` tactic<br>  and term.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.replace"><code><a class="type" href="Builtin.html#Builtin.replace"><span class="name function">replace</span></a>&ensp;:&ensp;{<span class="keyword">0</span>&ensp;<span class="boundvar">p</span>&ensp;:&ensp;<span class="boundvar">{_:423}</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">x</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">y</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">1</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">x</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">y</span></code></dt><dd><pre>  Perform substitution in a term according to some equality.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.sym"><code><a class="type" href="Builtin.html#Builtin.sym"><span class="name function">sym</span></a>&ensp;:&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">x</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">y</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">y</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Symmetry of propositional equality.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.trans"><code><a class="type" href="Builtin.html#Builtin.trans"><span class="name function">trans</span></a>&ensp;:&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">c</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">c</span></code></dt><dd><pre>  Transitivity of propositional equality.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.mkDPairInjectiveFst"><code><a class="type" href="Builtin.html#Builtin.mkDPairInjectiveFst"><span class="name function">mkDPairInjectiveFst</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">**</span>&ensp;<span class="boundvar">pa</span>)&ensp;<span class="keyword">=</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">**</span>&ensp;<span class="boundvar">qb</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Injectivity of MkDPair (first components)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Builtin.mkDPairInjectiveSnd"><code><a class="type" href="Builtin.html#Builtin.mkDPairInjectiveSnd"><span class="name function">mkDPairInjectiveSnd</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">**</span>&ensp;<span class="boundvar">pa</span>)&ensp;<span class="keyword">=</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">**</span>&ensp;<span class="boundvar">qa</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">pa</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">qa</span></code></dt><dd><pre>  Injectivity of MkDPair (snd components)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Builtin.believe_me"><code><a class="type" href="Builtin.html#Builtin.believe_me"><span class="name function">believe_me</span></a>&ensp;:&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Subvert the type checker.  This function is abstract, so it will not reduce<br>  in the type checker.  Use it with care - it can result in segfaults or<br>  worse!</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.assert_linear"><code><a class="type" href="Builtin.html#Builtin.assert_linear"><span class="name function">assert_linear</span></a>&ensp;:&ensp;(<span class="keyword">1</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">1</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Assert to the usage checker that the given function uses its argument linearly.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.idris_crash"><code><a class="type" href="Builtin.html#Builtin.idris_crash"><span class="name function">idris_crash</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Builtin.delay"><code><a class="type" href="Builtin.html#Builtin.delay"><span class="name function">delay</span></a>&ensp;:&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;Lazy&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.force"><code><a class="type" href="Builtin.html#Builtin.force"><span class="name function">force</span></a>&ensp;:&ensp;Lazy&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.FromString"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Builtin.html#Builtin.FromString"><span class="name type">FromString</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Interface for types that can be constructed from string literals.</pre><br>  <b>Parameters</b>:&ensp;ty<br><b>Constructor</b>:&ensp;<span class="implicit"><span class="name constructor">MkFromString</span></span><br><b>Methods</b>:<br><dl class="decls">  <dt id="Builtin.fromString"><code><a class="type" href="Builtin.html#Builtin.fromString"><span class="name function">fromString</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">ty</span></code></dt><dd><pre>  Conversion from String.</pre></dd></dl><br><b>Implementation</b>:&ensp;<dl class="decls"><dt id="$resolved359"><code><a class="type" href="Builtin.html#Builtin.FromString"><span class="name type">FromString</span></a>&ensp;<span class="name type">String</span></code></dt></dl></dd><dt id="Builtin.fromString"><code><a class="type" href="Builtin.html#Builtin.fromString"><span class="name function">fromString</span></a>&ensp;:&ensp;<a class="type" href="Builtin.html#Builtin.FromString"><span class="name type">FromString</span></a>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">ty</span></code></dt><dd><pre>  Conversion from String.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.defaultString"><code><a class="type" href="Builtin.html#Builtin.defaultString"><span class="name function">defaultString</span></a>&ensp;:&ensp;<a class="type" href="Builtin.html#Builtin.FromString"><span class="name type">FromString</span></a>&ensp;<span class="name type">String</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.FromChar"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Builtin.html#Builtin.FromChar"><span class="name type">FromChar</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Interface for types that can be constructed from char literals.</pre><br>  <b>Parameters</b>:&ensp;ty<br><b>Constructor</b>:&ensp;<span class="implicit"><span class="name constructor">MkFromChar</span></span><br><b>Methods</b>:<br><dl class="decls">  <dt id="Builtin.fromChar"><code><a class="type" href="Builtin.html#Builtin.fromChar"><span class="name function">fromChar</span></a>&ensp;:&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">ty</span></code></dt><dd><pre>  Conversion from Char.</pre></dd></dl><br><b>Implementation</b>:&ensp;<dl class="decls"><dt id="$resolved361"><code><a class="type" href="Builtin.html#Builtin.FromChar"><span class="name type">FromChar</span></a>&ensp;<span class="name type">Char</span></code></dt></dl></dd><dt id="Builtin.fromChar"><code><a class="type" href="Builtin.html#Builtin.fromChar"><span class="name function">fromChar</span></a>&ensp;:&ensp;<a class="type" href="Builtin.html#Builtin.FromChar"><span class="name type">FromChar</span></a>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">ty</span></code></dt><dd><pre>  Conversion from Char.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.defaultChar"><code><a class="type" href="Builtin.html#Builtin.defaultChar"><span class="name function">defaultChar</span></a>&ensp;:&ensp;<a class="type" href="Builtin.html#Builtin.FromChar"><span class="name type">FromChar</span></a>&ensp;<span class="name type">Char</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.FromDouble"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Builtin.html#Builtin.FromDouble"><span class="name type">FromDouble</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Interface for types that can be constructed from double literals.</pre><br>  <b>Parameters</b>:&ensp;ty<br><b>Constructor</b>:&ensp;<span class="implicit"><span class="name constructor">MkFromDouble</span></span><br><b>Methods</b>:<br><dl class="decls">  <dt id="Builtin.fromDouble"><code><a class="type" href="Builtin.html#Builtin.fromDouble"><span class="name function">fromDouble</span></a>&ensp;:&ensp;<span class="name type">Double</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">ty</span></code></dt><dd><pre>  Conversion from Double.</pre></dd></dl><br><b>Implementation</b>:&ensp;<dl class="decls"><dt id="$resolved360"><code><a class="type" href="Builtin.html#Builtin.FromDouble"><span class="name type">FromDouble</span></a>&ensp;<span class="name type">Double</span></code></dt></dl></dd><dt id="Builtin.fromDouble"><code><a class="type" href="Builtin.html#Builtin.fromDouble"><span class="name function">fromDouble</span></a>&ensp;:&ensp;<a class="type" href="Builtin.html#Builtin.FromDouble"><span class="name type">FromDouble</span></a>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="name type">Double</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">ty</span></code></dt><dd><pre>  Conversion from Double.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Builtin.defaultDouble"><code><a class="type" href="Builtin.html#Builtin.defaultDouble"><span class="name function">defaultDouble</span></a>&ensp;:&ensp;<a class="type" href="Builtin.html#Builtin.FromDouble"><span class="name type">FromDouble</span></a>&ensp;<span class="name type">Double</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd></dl></div><footer>Produced by Idris 2 version 0.6.0-f57e6f6eb</footer></body></html>