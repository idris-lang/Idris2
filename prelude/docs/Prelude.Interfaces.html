<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Prelude.Interfaces</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Prelude.Interfaces
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Prelude.Interfaces<span style="float:right">(<a href="../source/Prelude.Interfaces.html">source</a>)</span></h1><pre></pre></div><code></code><h2>Definitions</h2><dl class="decls"><dt id="Prelude.Interfaces.Semigroup"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Semigroup"><span class="name type">Semigroup</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Sets equipped with a single binary operation that is associative.  Must<br>  satisfy the following laws:<br>  <br>  + Associativity of `&lt;+&gt;`:<br>      forall a b c, a &lt;+&gt; (b &lt;+&gt; c) == (a &lt;+&gt; b) &lt;+&gt; c</pre><br>  <b>Parameters</b>:&ensp;ty<br><b>Constructor</b>:&ensp;<dl class="decls"><dt id="Prelude.Interfaces.MkSemigroup"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.MkSemigroup"><span class="name constructor">MkSemigroup</span></a></code></dt></dl><br><b>Methods</b>:<br><dl class="decls">  <dt id="Prelude.Interfaces.(&lt;+&gt;)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(&lt;+&gt;)"><span class="name function">(&lt;+&gt;)</span></a>&ensp;:&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">ty</span></code></dt><dd>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;8</dd></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved1614"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Semigroup"><span class="name type">Semigroup</span></a>&ensp;()</code></dt>  <dt id="$resolved1615"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Semigroup"><span class="name type">Semigroup</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Semigroup"><span class="name type">Semigroup</span></a>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Semigroup"><span class="name type">Semigroup</span></a>&ensp;(<span class="boundvar">a</span>,&ensp;<span class="boundvar">b</span>)</code></dt>  <dt id="$resolved1613"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Semigroup"><span class="name type">Semigroup</span></a>&ensp;<a class="type" href="Prelude.EqOrd.html#Prelude.EqOrd.Ordering"><span class="name type">Ordering</span></a></code></dt>  <dt id="$resolved1616"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Semigroup"><span class="name type">Semigroup</span></a>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Semigroup"><span class="name type">Semigroup</span></a>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)</code></dt>  <dt id="$resolved646"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Semigroup"><span class="name type">Semigroup</span></a>&ensp;(<a class="type" href="Prelude.Types.html#Prelude.Types.Maybe"><span class="name type">Maybe</span></a>&ensp;<span class="boundvar">a</span>)</code></dt>  <dt id="$resolved647"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Semigroup"><span class="name type">Semigroup</span></a>&ensp;(<a class="type" href="Prelude.Basics.html#Prelude.Basics.List"><span class="name type">List</span></a>&ensp;<span class="boundvar">a</span>)</code></dt>  <dt id="$resolved645"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Semigroup"><span class="name type">Semigroup</span></a>&ensp;<span class="name type">String</span></code></dt></dl></dd><dt id="Prelude.Interfaces.(&lt;+&gt;)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(&lt;+&gt;)"><span class="name function">(&lt;+&gt;)</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Semigroup"><span class="name type">Semigroup</span></a>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">ty</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;8</dd><dt id="Prelude.Interfaces.Monoid"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Sets equipped with a single binary operation that is associative, along with<br>  a neutral element for that binary operation.  Must satisfy the following<br>  laws:<br>  <br>  + Associativity of `&lt;+&gt;`:<br>      forall a b c, a &lt;+&gt; (b &lt;+&gt; c) == (a &lt;+&gt; b) &lt;+&gt; c<br>  + Neutral for `&lt;+&gt;`:<br>      forall a, a &lt;+&gt; neutral == a<br>      forall a, neutral &lt;+&gt; a == a</pre><br>  <b>Parameters</b>:&ensp;ty<br><b>Constraints</b>:&ensp;Semigroup&ensp;ty<br><b>Constructor</b>:&ensp;<dl class="decls"><dt id="Prelude.Interfaces.MkMonoid"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.MkMonoid"><span class="name constructor">MkMonoid</span></a></code></dt></dl><br><b>Methods</b>:<br><dl class="decls">  <dt id="Prelude.Interfaces.neutral"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.neutral"><span class="name function">neutral</span></a>&ensp;:&ensp;<span class="boundvar">ty</span></code></dt></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved1618"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;()</code></dt>  <dt id="$resolved1619"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;(<span class="boundvar">a</span>,&ensp;<span class="boundvar">b</span>)</code></dt>  <dt id="$resolved1617"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;<a class="type" href="Prelude.EqOrd.html#Prelude.EqOrd.Ordering"><span class="name type">Ordering</span></a></code></dt>  <dt id="$resolved1620"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)</code></dt>  <dt id="$resolved658"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;(<a class="type" href="Prelude.Types.html#Prelude.Types.Maybe"><span class="name type">Maybe</span></a>&ensp;<span class="boundvar">a</span>)</code></dt>  <dt id="$resolved659"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;(<a class="type" href="Prelude.Basics.html#Prelude.Basics.List"><span class="name type">List</span></a>&ensp;<span class="boundvar">a</span>)</code></dt>  <dt id="$resolved657"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;<span class="name type">String</span></code></dt></dl></dd><dt id="Prelude.Interfaces.neutral"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.neutral"><span class="name function">neutral</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;<span class="boundvar">ty</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">ty</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.Functor"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Functor"><span class="name type">Functor</span></a>&ensp;:&ensp;(<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Functors allow a uniform action over a parameterised type.<br>  @ f a parameterised type</pre><br>  <b>Parameters</b>:&ensp;f<br><b>Constructor</b>:&ensp;<dl class="decls"><dt id="Prelude.Interfaces.MkFunctor"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.MkFunctor"><span class="name constructor">MkFunctor</span></a></code></dt></dl><br><b>Methods</b>:<br><dl class="decls">  <dt id="Prelude.Interfaces.map"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.map"><span class="name function">map</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Apply a function across everything of type &apos;a&apos; in a parameterised type<br>  @ f the parameterised type<br>  @ func the function to apply</pre></dd></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved2227"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Functor"><span class="name type">Functor</span></a>&ensp;<a class="type" href="PrimIO.html#PrimIO.IO"><span class="name type">IO</span></a></code></dt>  <dt id="$resolved667"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Functor"><span class="name type">Functor</span></a>&ensp;(<a class="type" href="Builtin.html#Builtin.Pair"><span class="name type">Pair</span></a>&ensp;<span class="boundvar">a</span>)</code></dt>  <dt id="$resolved665"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Functor"><span class="name type">Functor</span></a>&ensp;<a class="type" href="Prelude.Types.html#Prelude.Types.Maybe"><span class="name type">Maybe</span></a></code></dt>  <dt id="$resolved668"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Functor"><span class="name type">Functor</span></a>&ensp;(<a class="type" href="Prelude.Types.html#Prelude.Types.Either"><span class="name type">Either</span></a>&ensp;<span class="boundvar">e</span>)</code></dt>  <dt id="$resolved666"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Functor"><span class="name type">Functor</span></a>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.List"><span class="name type">List</span></a></code></dt>  <dt id="$resolved664"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Functor"><span class="name type">Functor</span></a>&ensp;<span class="type resolved" title="Prelude.Types.Stream.Stream"><span class="name type">Stream</span></span></code></dt></dl></dd><dt id="Prelude.Interfaces.map"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.map"><span class="name function">map</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Functor"><span class="name type">Functor</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Apply a function across everything of type &apos;a&apos; in a parameterised type<br>  @ f the parameterised type<br>  @ func the function to apply</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.(&lt;$&gt;)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(&lt;$&gt;)"><span class="name function">(&lt;$&gt;)</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Functor"><span class="name type">Functor</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  An infix alias for `map`, applying a function across everything of type &apos;a&apos;<br>  in a parameterised type.<br>  @ f the parameterised type<br>  @ func the function to apply</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;4</dd><dt id="Prelude.Interfaces.(&lt;&amp;&gt;)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(&lt;&amp;&gt;)"><span class="name function">(&lt;&amp;&gt;)</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Functor"><span class="name type">Functor</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Flipped version of `&lt;$&gt;`, an infix alias for `map`, applying a function across<br>  everything of type &apos;a&apos; in a parameterised type.<br>  @ f the parameterised type<br>  @ func the function to apply</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;1</dd><dt id="Prelude.Interfaces.(&lt;$)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(&lt;$)"><span class="name function">(&lt;$)</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Functor"><span class="name type">Functor</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Run something for effects, replacing the return value with a given parameter.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;4</dd><dt id="Prelude.Interfaces.($&gt;)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.($&gt;)"><span class="name function">($&gt;)</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Functor"><span class="name type">Functor</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Flipped version of `&lt;$`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;4</dd><dt id="Prelude.Interfaces.ignore"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.ignore"><span class="name function">ignore</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Functor"><span class="name type">Functor</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;()</code></dt><dd><pre>  Run something for effects, throwing away the return value.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.Bifunctor"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bifunctor"><span class="name type">Bifunctor</span></a>&ensp;:&ensp;(<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Bifunctors<br>  @f The action of the Bifunctor on pairs of objects<br>  A minimal definition includes either `bimap` or both `mapFst` and `mapSnd`.</pre><br>  <b>Parameters</b>:&ensp;f<br><b>Constructor</b>:&ensp;<dl class="decls"><dt id="Prelude.Interfaces.MkBifunctor"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.MkBifunctor"><span class="name constructor">MkBifunctor</span></a></code></dt></dl><br><b>Methods</b>:<br><dl class="decls">  <dt id="Prelude.Interfaces.bimap"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.bimap"><span class="name function">bimap</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">c</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">d</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  The action of the Bifunctor on pairs of morphisms<br>  <br>  ````idris example<br>  bimap (\x =&gt; x + 1) reverse (1, &quot;hello&quot;) == (2, &quot;olleh&quot;)<br>  ````<br>  </pre></dd>  <dt id="Prelude.Interfaces.mapFst"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.mapFst"><span class="name function">mapFst</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">c</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  The action of the Bifunctor on morphisms pertaining to the first object<br>  <br>  ````idris example<br>  mapFst (\x =&gt; x + 1) (1, &quot;hello&quot;) == (2, &quot;hello&quot;)<br>  ````<br>  </pre></dd>  <dt id="Prelude.Interfaces.mapSnd"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.mapSnd"><span class="name function">mapSnd</span></a>&ensp;:&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">d</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  The action of the Bifunctor on morphisms pertaining to the second object<br>  <br>  ````idris example<br>  mapSnd reverse (1, &quot;hello&quot;) == (1, &quot;olleh&quot;)<br>  ````<br>  </pre></dd></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved680"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bifunctor"><span class="name type">Bifunctor</span></a>&ensp;<a class="type" href="Builtin.html#Builtin.Pair"><span class="name type">Pair</span></a></code></dt>  <dt id="$resolved681"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bifunctor"><span class="name type">Bifunctor</span></a>&ensp;<a class="type" href="Prelude.Types.html#Prelude.Types.Either"><span class="name type">Either</span></a></code></dt></dl></dd><dt id="Prelude.Interfaces.bimap"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.bimap"><span class="name function">bimap</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bifunctor"><span class="name type">Bifunctor</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">c</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">d</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  The action of the Bifunctor on pairs of morphisms<br>  <br>  ````idris example<br>  bimap (\x =&gt; x + 1) reverse (1, &quot;hello&quot;) == (2, &quot;olleh&quot;)<br>  ````<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.mapFst"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.mapFst"><span class="name function">mapFst</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bifunctor"><span class="name type">Bifunctor</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">c</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  The action of the Bifunctor on morphisms pertaining to the first object<br>  <br>  ````idris example<br>  mapFst (\x =&gt; x + 1) (1, &quot;hello&quot;) == (2, &quot;hello&quot;)<br>  ````<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.mapSnd"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.mapSnd"><span class="name function">mapSnd</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bifunctor"><span class="name type">Bifunctor</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">d</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">d</span></code></dt><dd><pre>  The action of the Bifunctor on morphisms pertaining to the second object<br>  <br>  ````idris example<br>  mapSnd reverse (1, &quot;hello&quot;) == (1, &quot;olleh&quot;)<br>  ````<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.mapHom"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.mapHom"><span class="name function">mapHom</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bifunctor"><span class="name type">Bifunctor</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">b</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.Applicative"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;:&ensp;(<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Parameters</b>:&ensp;f<br><b>Constraints</b>:&ensp;Functor&ensp;f<br><b>Constructor</b>:&ensp;<dl class="decls"><dt id="Prelude.Interfaces.MkApplicative"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.MkApplicative"><span class="name constructor">MkApplicative</span></a></code></dt></dl><br><b>Methods</b>:<br><dl class="decls">  <dt id="Prelude.Interfaces.pure"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.pure"><span class="name function">pure</span></a>&ensp;:&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span></code></dt>  <dt id="Prelude.Interfaces.(&lt;*&gt;)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(&lt;*&gt;)"><span class="name function">(&lt;*&gt;)</span></a>&ensp;:&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span></code></dt><dd>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;3</dd></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved2228"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<a class="type" href="PrimIO.html#PrimIO.IO"><span class="name type">IO</span></a></code></dt>  <dt id="$resolved686"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;(<a class="type" href="Builtin.html#Builtin.Pair"><span class="name type">Pair</span></a>&ensp;<span class="boundvar">a</span>)</code></dt>  <dt id="$resolved684"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<a class="type" href="Prelude.Types.html#Prelude.Types.Maybe"><span class="name type">Maybe</span></a></code></dt>  <dt id="$resolved687"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;(<a class="type" href="Prelude.Types.html#Prelude.Types.Either"><span class="name type">Either</span></a>&ensp;<span class="boundvar">e</span>)</code></dt>  <dt id="$resolved685"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.List"><span class="name type">List</span></a></code></dt></dl></dd><dt id="Prelude.Interfaces.pure"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.pure"><span class="name function">pure</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.(&lt;*&gt;)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(&lt;*&gt;)"><span class="name function">(&lt;*&gt;)</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;3</dd><dt id="Prelude.Interfaces.(&lt;*)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(&lt;*)"><span class="name function">(&lt;*)</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;3</dd><dt id="Prelude.Interfaces.(*&gt;)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(*&gt;)"><span class="name function">(*&gt;)</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;3</dd><dt id="Prelude.Interfaces.Alternative"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Alternative"><span class="name type">Alternative</span></a>&ensp;:&ensp;(<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  An alternative functor has a notion of disjunction.<br>  @f is the underlying applicative functor<br>  We expect (f a, empty, (&lt;|&gt;)) to be a type family of monoids.</pre><br>  <b>Parameters</b>:&ensp;f<br><b>Constraints</b>:&ensp;Applicative&ensp;f<br><b>Constructor</b>:&ensp;<dl class="decls"><dt id="Prelude.Interfaces.MkAlternative"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.MkAlternative"><span class="name constructor">MkAlternative</span></a></code></dt></dl><br><b>Methods</b>:<br><dl class="decls">  <dt id="Prelude.Interfaces.empty"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.empty"><span class="name function">empty</span></a>&ensp;:&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span></code></dt>  <dt id="Prelude.Interfaces.(&lt;|&gt;)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(&lt;|&gt;)"><span class="name function">(&lt;|&gt;)</span></a>&ensp;:&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;Lazy&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;2</dd></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved688"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Alternative"><span class="name type">Alternative</span></a>&ensp;<a class="type" href="Prelude.Types.html#Prelude.Types.Maybe"><span class="name type">Maybe</span></a></code></dt>  <dt id="$resolved689"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Alternative"><span class="name type">Alternative</span></a>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.List"><span class="name type">List</span></a></code></dt></dl></dd><dt id="Prelude.Interfaces.empty"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.empty"><span class="name function">empty</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Alternative"><span class="name type">Alternative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.(&lt;|&gt;)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(&lt;|&gt;)"><span class="name function">(&lt;|&gt;)</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Alternative"><span class="name type">Alternative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;Lazy&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;2</dd><dt id="Prelude.Interfaces.Monad"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monad"><span class="name type">Monad</span></a>&ensp;:&ensp;(<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Monad<br>  @m The underlying functor<br>  A minimal definition includes either `(&gt;&gt;=)` or `join`.</pre><br>  <b>Parameters</b>:&ensp;m<br><b>Constraints</b>:&ensp;Applicative&ensp;m<br><b>Constructor</b>:&ensp;<dl class="decls"><dt id="Prelude.Interfaces.MkMonad"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.MkMonad"><span class="name constructor">MkMonad</span></a></code></dt></dl><br><b>Methods</b>:<br><dl class="decls">  <dt id="Prelude.Interfaces.(&gt;&gt;=)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(&gt;&gt;=)"><span class="name function">(&gt;&gt;=)</span></a>&ensp;:&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Also called `bind`.</pre><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;1</dd>  <dt id="Prelude.Interfaces.join"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.join"><span class="name function">join</span></a>&ensp;:&ensp;<span class="boundvar">m</span>&ensp;(<span class="boundvar">m</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Also called `flatten` or mu.</pre></dd></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved2224"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monad"><span class="name type">Monad</span></a>&ensp;<a class="type" href="PrimIO.html#PrimIO.IO"><span class="name type">IO</span></a></code></dt>  <dt id="$resolved662"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monad"><span class="name type">Monad</span></a>&ensp;(<a class="type" href="Builtin.html#Builtin.Pair"><span class="name type">Pair</span></a>&ensp;<span class="boundvar">a</span>)</code></dt>  <dt id="$resolved660"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monad"><span class="name type">Monad</span></a>&ensp;<a class="type" href="Prelude.Types.html#Prelude.Types.Maybe"><span class="name type">Maybe</span></a></code></dt>  <dt id="$resolved663"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monad"><span class="name type">Monad</span></a>&ensp;(<a class="type" href="Prelude.Types.html#Prelude.Types.Either"><span class="name type">Either</span></a>&ensp;<span class="boundvar">e</span>)</code></dt>  <dt id="$resolved661"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monad"><span class="name type">Monad</span></a>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.List"><span class="name type">List</span></a></code></dt></dl></dd><dt id="Prelude.Interfaces.(&gt;&gt;=)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(&gt;&gt;=)"><span class="name function">(&gt;&gt;=)</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monad"><span class="name type">Monad</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Also called `bind`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;1</dd><dt id="Prelude.Interfaces.join"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.join"><span class="name function">join</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monad"><span class="name type">Monad</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;(<span class="boundvar">m</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Also called `flatten` or mu.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.(=&lt;&lt;)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(=&lt;&lt;)"><span class="name function">(=&lt;&lt;)</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monad"><span class="name type">Monad</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Right-to-left monadic bind, flipped version of `&gt;&gt;=`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;1</dd><dt id="Prelude.Interfaces.(&gt;&gt;)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(&gt;&gt;)"><span class="name function">(&gt;&gt;)</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monad"><span class="name type">Monad</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;()&ensp;<span class="keyword">-&gt;</span>&ensp;Lazy&ensp;(<span class="boundvar">m</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Sequencing of effectful composition</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;1</dd><dt id="Prelude.Interfaces.(&gt;=&gt;)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(&gt;=&gt;)"><span class="name function">(&gt;=&gt;)</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monad"><span class="name type">Monad</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">c</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">c</span></code></dt><dd><pre>  Left-to-right Kleisli composition of monads.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;1</dd><dt id="Prelude.Interfaces.(&lt;=&lt;)"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.(&lt;=&lt;)"><span class="name function">(&lt;=&lt;)</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monad"><span class="name type">Monad</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">c</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">c</span></code></dt><dd><pre>  Right-to-left Kleisli composition of monads, flipped version of `&gt;=&gt;`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;1</dd><dt id="Prelude.Interfaces.guard"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.guard"><span class="name function">guard</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Alternative"><span class="name type">Alternative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.Bool"><span class="name type">Bool</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;()</code></dt><dd><pre>  `guard a` is `pure ()` if `a` is `True` and `empty` if `a` is `False`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.when"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.when"><span class="name function">when</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.Bool"><span class="name type">Bool</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;Lazy&ensp;(<span class="boundvar">f</span>&ensp;())&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;()</code></dt><dd><pre>  Conditionally execute an applicative expression when the boolean is true.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.unless"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.unless"><span class="name function">unless</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.Bool"><span class="name type">Bool</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;Lazy&ensp;(<span class="boundvar">f</span>&ensp;())&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;()</code></dt><dd><pre>  Execute an applicative expression unless the boolean is true.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.Foldable"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;:&ensp;(<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  The `Foldable` interface describes how you can iterate over the elements in<br>  a parameterised type and combine the elements together, using a provided<br>  function, into a single result.<br>  @ t The type of the &apos;Foldable&apos; parameterised type.<br>  A minimal definition includes `foldr`</pre><br>  <b>Parameters</b>:&ensp;t<br><b>Constructor</b>:&ensp;<dl class="decls"><dt id="Prelude.Interfaces.MkFoldable"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.MkFoldable"><span class="name constructor">MkFoldable</span></a></code></dt></dl><br><b>Methods</b>:<br><dl class="decls">  <dt id="Prelude.Interfaces.foldr"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.foldr"><span class="name function">foldr</span></a>&ensp;:&ensp;(<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span></code></dt><dd><pre>  Successively combine the elements in a parameterised type using the<br>  provided function, starting with the element that is in the final position<br>  i.e. the right-most position.<br>  @ func  The function used to &apos;fold&apos; an element into the accumulated result<br>  @ init  The starting value the results are being combined into<br>  @ input The parameterised type</pre></dd>  <dt id="Prelude.Interfaces.foldl"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.foldl"><span class="name function">foldl</span></a>&ensp;:&ensp;(<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span></code></dt><dd><pre>  The same as `foldr` but begins the folding from the element at the initial<br>  position in the data structure i.e. the left-most position.<br>  @ func  The function used to &apos;fold&apos; an element into the accumulated result<br>  @ init  The starting value the results are being combined into<br>  @ input The parameterised type</pre></dd>  <dt id="Prelude.Interfaces.null"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.null"><span class="name function">null</span></a>&ensp;:&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.Bool"><span class="name type">Bool</span></a></code></dt><dd><pre>  Test whether the structure is empty.<br>  @ acc The accumulator value which is specified to be lazy</pre></dd>  <dt id="Prelude.Interfaces.foldlM"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.foldlM"><span class="name function">foldlM</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monad"><span class="name type">Monad</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">acc</span></code></dt><dd><pre>  Similar to `foldl`, but uses a function wrapping its result in a `Monad`.<br>  Consequently, the final value is wrapped in the same `Monad`.</pre></dd>  <dt id="Prelude.Interfaces.toList"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.toList"><span class="name function">toList</span></a>&ensp;:&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.List"><span class="name type">List</span></a>&ensp;<span class="boundvar">elem</span></code></dt><dd><pre>  Produce a list of the elements contained in the parametrised type.</pre></dd>  <dt id="Prelude.Interfaces.foldMap"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.foldMap"><span class="name function">foldMap</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span></code></dt><dd><pre>  Maps each element to a value and combine them.<br>  For performance reasons, this should wherever<br>  be implemented with tail recursion.<br>  @ f The function to apply to each element.</pre></dd></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved671"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;(<a class="type" href="Builtin.html#Builtin.Pair"><span class="name type">Pair</span></a>&ensp;<span class="boundvar">a</span>)</code></dt>  <dt id="$resolved669"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<a class="type" href="Prelude.Types.html#Prelude.Types.Maybe"><span class="name type">Maybe</span></a></code></dt>  <dt id="$resolved672"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;(<a class="type" href="Prelude.Types.html#Prelude.Types.Either"><span class="name type">Either</span></a>&ensp;<span class="boundvar">e</span>)</code></dt>  <dt id="$resolved670"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.List"><span class="name type">List</span></a></code></dt></dl></dd><dt id="Prelude.Interfaces.foldr"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.foldr"><span class="name function">foldr</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span></code></dt><dd><pre>  Successively combine the elements in a parameterised type using the<br>  provided function, starting with the element that is in the final position<br>  i.e. the right-most position.<br>  @ func  The function used to &apos;fold&apos; an element into the accumulated result<br>  @ init  The starting value the results are being combined into<br>  @ input The parameterised type</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.foldl"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.foldl"><span class="name function">foldl</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span></code></dt><dd><pre>  The same as `foldr` but begins the folding from the element at the initial<br>  position in the data structure i.e. the left-most position.<br>  @ func  The function used to &apos;fold&apos; an element into the accumulated result<br>  @ init  The starting value the results are being combined into<br>  @ input The parameterised type</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.null"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.null"><span class="name function">null</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.Bool"><span class="name type">Bool</span></a></code></dt><dd><pre>  Test whether the structure is empty.<br>  @ acc The accumulator value which is specified to be lazy</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.foldlM"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.foldlM"><span class="name function">foldlM</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monad"><span class="name type">Monad</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">acc</span></code></dt><dd><pre>  Similar to `foldl`, but uses a function wrapping its result in a `Monad`.<br>  Consequently, the final value is wrapped in the same `Monad`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.toList"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.toList"><span class="name function">toList</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.List"><span class="name type">List</span></a>&ensp;<span class="boundvar">elem</span></code></dt><dd><pre>  Produce a list of the elements contained in the parametrised type.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.foldMap"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.foldMap"><span class="name function">foldMap</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span></code></dt><dd><pre>  Maps each element to a value and combine them.<br>  For performance reasons, this should wherever<br>  be implemented with tail recursion.<br>  @ f The function to apply to each element.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.concat"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.concat"><span class="name function">concat</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Combine each element of a structure into a monoid.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.concatMap"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.concatMap"><span class="name function">concatMap</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span></code></dt><dd><pre>  Combine into a monoid the collective results of applying a function to each<br>  element of a structure.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.and"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.and"><span class="name function">and</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;(Lazy&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.Bool"><span class="name type">Bool</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.Bool"><span class="name type">Bool</span></a></code></dt><dd><pre>  The conjunction of all elements of a structure containing lazy boolean<br>  values.  `and` short-circuits from left to right, evaluating until either an<br>  element is `False` or no elements remain.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.or"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.or"><span class="name function">or</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;(Lazy&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.Bool"><span class="name type">Bool</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.Bool"><span class="name type">Bool</span></a></code></dt><dd><pre>  The disjunction of all elements of a structure containing lazy boolean<br>  values.  `or` short-circuits from left to right, evaluating either until an<br>  element is `True` or no elements remain.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.any"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.any"><span class="name function">any</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.Bool"><span class="name type">Bool</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.Bool"><span class="name type">Bool</span></a></code></dt><dd><pre>  The disjunction of the collective results of applying a predicate to all<br>  elements of a structure.  `any` short-circuits from left to right.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.all"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.all"><span class="name function">all</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.Bool"><span class="name type">Bool</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.Bool"><span class="name type">Bool</span></a></code></dt><dd><pre>  The conjunction of the collective results of applying a predicate to all<br>  elements of a structure.  `all` short-circuits from left to right.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.sum"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.sum"><span class="name function">sum</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Num.html#Prelude.Num.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Add together all the elements of a structure.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.sum&apos;"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.sum&apos;"><span class="name function">sum&apos;</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Num.html#Prelude.Num.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Add together all the elements of a structure.<br>  Same as `sum` but tail recursive.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Prelude.Interfaces.product"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.product"><span class="name function">product</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Num.html#Prelude.Num.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Multiply together all elements of a structure.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.product&apos;"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.product&apos;"><span class="name function">product&apos;</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Num.html#Prelude.Num.Num"><span class="name type">Num</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Multiply together all elements of a structure.<br>  Same as `product` but tail recursive.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Prelude.Interfaces.traverse_"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.traverse_"><span class="name function">traverse_</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;()</code></dt><dd><pre>  Map each element of a structure to a computation, evaluate those<br>  computations and discard the results.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.sequence_"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.sequence_"><span class="name function">sequence_</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;()</code></dt><dd><pre>  Evaluate each computation in a structure and discard the results.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.for_"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.for_"><span class="name function">for_</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;()</code></dt><dd><pre>  Like `traverse_` but with the arguments flipped.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.choice"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.choice"><span class="name function">choice</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Alternative"><span class="name type">Alternative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;(Lazy&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Fold using Alternative.<br>  <br>  If you have a left-biased alternative operator `&lt;|&gt;`, then `choice` performs<br>  left-biased choice from a list of alternatives, which means that it<br>  evaluates to the left-most non-`empty` alternative.<br>  <br>  If the list is empty, or all values in it are `empty`, then it evaluates to<br>  `empty`.<br>  <br>  Example:<br>  <br>  ```<br>  -- given a parser expression like:<br>  expr = literal &lt;|&gt; keyword &lt;|&gt; funcall<br>  <br>  -- choice lets you write this as:<br>  expr = choice [literal, keyword, funcall]<br>  ```<br>  <br>  Note: In Haskell, `choice` is called `asum`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.choiceMap"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.choiceMap"><span class="name function">choiceMap</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Alternative"><span class="name type">Alternative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  A fused version of `choice` and `map`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.Bifoldable"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bifoldable"><span class="name type">Bifoldable</span></a>&ensp;:&ensp;(<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  `Bifoldable` identifies foldable structures with two different varieties<br>  of elements (as opposed to `Foldable`, which has one variety of element).<br>  Common examples are `Either` and `Pair`.<br>  A minimal definition includes `bifoldr`</pre><br>  <b>Parameters</b>:&ensp;p<br><b>Constructor</b>:&ensp;<dl class="decls"><dt id="Prelude.Interfaces.MkBifoldable"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.MkBifoldable"><span class="name constructor">MkBifoldable</span></a></code></dt></dl><br><b>Methods</b>:<br><dl class="decls">  <dt id="Prelude.Interfaces.bifoldr"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.bifoldr"><span class="name function">bifoldr</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span></code></dt>  <dt id="Prelude.Interfaces.bifoldl"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.bifoldl"><span class="name function">bifoldl</span></a>&ensp;:&ensp;(<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span></code></dt>  <dt id="Prelude.Interfaces.binull"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.binull"><span class="name function">binull</span></a>&ensp;:&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.Bool"><span class="name type">Bool</span></a></code></dt></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved682"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bifoldable"><span class="name type">Bifoldable</span></a>&ensp;<a class="type" href="Builtin.html#Builtin.Pair"><span class="name type">Pair</span></a></code></dt>  <dt id="$resolved683"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bifoldable"><span class="name type">Bifoldable</span></a>&ensp;<a class="type" href="Prelude.Types.html#Prelude.Types.Either"><span class="name type">Either</span></a></code></dt></dl></dd><dt id="Prelude.Interfaces.bifoldr"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.bifoldr"><span class="name function">bifoldr</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bifoldable"><span class="name type">Bifoldable</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.bifoldl"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.bifoldl"><span class="name function">bifoldl</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bifoldable"><span class="name type">Bifoldable</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.binull"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.binull"><span class="name function">binull</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bifoldable"><span class="name type">Bifoldable</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.Bool"><span class="name type">Bool</span></a></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.bifoldMap"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.bifoldMap"><span class="name function">bifoldMap</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bifoldable"><span class="name type">Bifoldable</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span></code></dt><dd><pre>  Analogous to `foldMap` but for `Bifoldable` structures</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.bifoldMapFst"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.bifoldMapFst"><span class="name function">bifoldMapFst</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></a>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bifoldable"><span class="name type">Bifoldable</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span></code></dt><dd><pre>  Like Bifunctor&apos;s `mapFst` but for `Bifoldable` structures</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.Traversable"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Traversable"><span class="name type">Traversable</span></a>&ensp;:&ensp;(<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Parameters</b>:&ensp;t<br><b>Constraints</b>:&ensp;Functor&ensp;t,&ensp;Foldable&ensp;t<br><b>Constructor</b>:&ensp;<dl class="decls"><dt id="Prelude.Interfaces.MkTraversable"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.MkTraversable"><span class="name constructor">MkTraversable</span></a></code></dt></dl><br><b>Methods</b>:<br><dl class="decls">  <dt id="Prelude.Interfaces.traverse"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.traverse"><span class="name function">traverse</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">t</span>&ensp;<span class="boundvar">b</span>)</code></dt><dd><pre>  Map each element of a structure to a computation, evaluate those<br>  computations and combine the results.</pre></dd></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved643"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Traversable"><span class="name type">Traversable</span></a>&ensp;(<a class="type" href="Builtin.html#Builtin.Pair"><span class="name type">Pair</span></a>&ensp;<span class="boundvar">a</span>)</code></dt>  <dt id="$resolved641"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Traversable"><span class="name type">Traversable</span></a>&ensp;<a class="type" href="Prelude.Types.html#Prelude.Types.Maybe"><span class="name type">Maybe</span></a></code></dt>  <dt id="$resolved644"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Traversable"><span class="name type">Traversable</span></a>&ensp;(<a class="type" href="Prelude.Types.html#Prelude.Types.Either"><span class="name type">Either</span></a>&ensp;<span class="boundvar">e</span>)</code></dt>  <dt id="$resolved642"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Traversable"><span class="name type">Traversable</span></a>&ensp;<a class="type" href="Prelude.Basics.html#Prelude.Basics.List"><span class="name type">List</span></a></code></dt></dl></dd><dt id="Prelude.Interfaces.traverse"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.traverse"><span class="name function">traverse</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Traversable"><span class="name type">Traversable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">t</span>&ensp;<span class="boundvar">b</span>)</code></dt><dd><pre>  Map each element of a structure to a computation, evaluate those<br>  computations and combine the results.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.sequence"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.sequence"><span class="name function">sequence</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Traversable"><span class="name type">Traversable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Evaluate each computation in a structure and collect the results.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.for"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.for"><span class="name function">for</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Traversable"><span class="name type">Traversable</span></a>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">t</span>&ensp;<span class="boundvar">b</span>)</code></dt><dd><pre>  Like `traverse` but with the arguments flipped.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.Bitraversable"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bitraversable"><span class="name type">Bitraversable</span></a>&ensp;:&ensp;(<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Parameters</b>:&ensp;p<br><b>Constraints</b>:&ensp;Bifunctor&ensp;p,&ensp;Bifoldable&ensp;p<br><b>Constructor</b>:&ensp;<dl class="decls"><dt id="Prelude.Interfaces.MkBitraversable"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.MkBitraversable"><span class="name constructor">MkBitraversable</span></a></code></dt></dl><br><b>Methods</b>:<br><dl class="decls">  <dt id="Prelude.Interfaces.bitraverse"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.bitraverse"><span class="name function">bitraverse</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">c</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">d</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">d</span>)</code></dt><dd><pre>  Map each element of a structure to a computation, evaluate those<br>  computations and combine the results.</pre></dd></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved678"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bitraversable"><span class="name type">Bitraversable</span></a>&ensp;<a class="type" href="Builtin.html#Builtin.Pair"><span class="name type">Pair</span></a></code></dt>  <dt id="$resolved679"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bitraversable"><span class="name type">Bitraversable</span></a>&ensp;<a class="type" href="Prelude.Types.html#Prelude.Types.Either"><span class="name type">Either</span></a></code></dt></dl></dd><dt id="Prelude.Interfaces.bitraverse"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.bitraverse"><span class="name function">bitraverse</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bitraversable"><span class="name type">Bitraversable</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">c</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">d</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">d</span>)</code></dt><dd><pre>  Map each element of a structure to a computation, evaluate those<br>  computations and combine the results.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.bisequence"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.bisequence"><span class="name function">bisequence</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bitraversable"><span class="name type">Bitraversable</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>)&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>)</code></dt><dd><pre>  Evaluate each computation in a structure and collect the results.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Prelude.Interfaces.bifor"><code><a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.bifor"><span class="name function">bifor</span></a>&ensp;:&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></a>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Prelude.Interfaces.html#Prelude.Interfaces.Bitraversable"><span class="name type">Bitraversable</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">c</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">d</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">d</span>)</code></dt><dd><pre>  Like `bitraverse` but with the arguments flipped.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd></dl></div><footer>Produced by Idris 2 version 0.7.0-73bb183cc</footer></body></html>