<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>papers</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="index">
<header>
  <strong>Idris2Doc</strong> : papers
  <nav><a href="index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><h1>Package papers - Namespaces</h1><ul class="names"><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Control.DivideAndConquer.html">Control.DivideAndConquer</a>
    </div>
    <div class="index-namespace-doc">
      The content of this module is based on the paper
A Type-Based Approach to Divide-And-Conquer Recursion in Coq
by Pedro Abreu, Benjamin Delaware, Alex Hubers, Christa Jenkins,
J. Garret Morris, and Aaron Stump
https://doi.org/10.1145/3571196

The original paper relies on Coq's impredicative Set axiom,
something we don't have access to in Idris 2. We can however
reproduce the results by ignoring the type levels

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Data.Container.html">Data.Container</a>
    </div>
    <div class="index-namespace-doc">
      
    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Data.Description.Regular.html">Data.Description.Regular</a>
    </div>
    <div class="index-namespace-doc">
      The content of this module is based on the paper
A Completely Unique Account of Enumeration
by Cas van der Rest, and Wouter Swierstra
https://doi.org/10.1145/3547636

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Data.Description.Indexed.html">Data.Description.Indexed</a>
    </div>
    <div class="index-namespace-doc">
      The content of this module is based on the paper
A Completely Unique Account of Enumeration
by Cas van der Rest, and Wouter Swierstra
https://doi.org/10.1145/3547636

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Data.Enumerate.html">Data.Enumerate</a>
    </div>
    <div class="index-namespace-doc">
      The content of this module is based on the paper
A Completely Unique Account of Enumeration
by Cas van der Rest, and Wouter Swierstra
https://doi.org/10.1145/3547636

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Data.Enumerate.Common.html">Data.Enumerate.Common</a>
    </div>
    <div class="index-namespace-doc">
      
    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Data.Enumerate.Indexed.html">Data.Enumerate.Indexed</a>
    </div>
    <div class="index-namespace-doc">
      The content of this module is based on the paper
A Completely Unique Account of Enumeration
by Cas van der Rest, and Wouter Swierstra
https://doi.org/10.1145/3547636

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Data.InductionRecursion.DybjerSetzer.html">Data.InductionRecursion.DybjerSetzer</a>
    </div>
    <div class="index-namespace-doc">
      There are different flavours of induction-recursion. This is the one
introduced in Dybjer and Setzer's paper:
Indexed induction-recursion

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Data.INTEGER.html">Data.INTEGER</a>
    </div>
    <div class="index-namespace-doc">
      
    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Data.Linear.Communications.html">Data.Linear.Communications</a>
    </div>
    <div class="index-namespace-doc">
      This module is based on the content of the functional pearl
How to Take the Inverse of a Type
by Daniel Marshall and Dominic Orchard

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Data.Linear.Diff.html">Data.Linear.Diff</a>
    </div>
    <div class="index-namespace-doc">
      This module is based on the content of the functional pearl
How to Take the Inverse of a Type
by Daniel Marshall and Dominic Orchard

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Data.Linear.Inverse.html">Data.Linear.Inverse</a>
    </div>
    <div class="index-namespace-doc">
      This module is based on the content of the functional pearl
How to Take the Inverse of a Type
by Daniel Marshall and Dominic Orchard

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Data.ProofDelay.html">Data.ProofDelay</a>
    </div>
    <div class="index-namespace-doc">
      The contents of this module are based on the paper
Deferring the Details and Deriving Programs
by Liam O'Connor
https://doi.org/10.1145/3331554.3342605

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Data.Recursion.Free.html">Data.Recursion.Free</a>
    </div>
    <div class="index-namespace-doc">
      Module partially based on McBride's paper:
Turing-Completeness Totally Free

It gives us a type to describe computation using general recursion
and functions to run these computations for a while or to completion
if we are able to prove them total.

The content of the Erased section is new. Instead of producing the
domain/evaluation pair by computing a Dybjer-Setzer code we build a
specialised structure that allows us to make the domain proof runtime
irrelevant.

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Data.Tree.Perfect.html">Data.Tree.Perfect</a>
    </div>
    <div class="index-namespace-doc">
      
    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Data.Vect.Binary.html">Data.Vect.Binary</a>
    </div>
    <div class="index-namespace-doc">
      The content of this file is taken from the paper
Heterogeneous Binary Random-access lists

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Data.W.html">Data.W</a>
    </div>
    <div class="index-namespace-doc">
      
    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Language.IntrinsicScoping.Variables.html">Language.IntrinsicScoping.Variables</a>
    </div>
    <div class="index-namespace-doc">
      
    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Language.IntrinsicScoping.TypeTheory.html">Language.IntrinsicScoping.TypeTheory</a>
    </div>
    <div class="index-namespace-doc">
      The content of this module is based on the paper:
A tutorial implementation of a dependently typed lambda calculus
by Andres LÃ¶h, Conor McBride, and Wouter Swierstra

NB: Unlike `Language.TypeTheory`, this is not a direct translation
    of the code in the paper but rather a more idiomatic solution.

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Language.IntrinsicTyping.ABT.html">Language.IntrinsicTyping.ABT</a>
    </div>
    <div class="index-namespace-doc">
      Abstract binding trees are a generic representation of terms over
a given signature

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Language.IntrinsicTyping.Krivine.html">Language.IntrinsicTyping.Krivine</a>
    </div>
    <div class="index-namespace-doc">
      The content of this module is based on the paper
From Mathematics to Abstract Machine
A formal derivation of an executable Krivine machine
by Wouter Swierstra

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Language.IntrinsicTyping.SECD.html">Language.IntrinsicTyping.SECD</a>
    </div>
    <div class="index-namespace-doc">
      The content of this module is based on the MSc Thesis
Coinductive Formalization of SECD Machine in Agda
by Adam KrupiÄka

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Language.IntrinsicTyping.STLCR.html">Language.IntrinsicTyping.STLCR</a>
    </div>
    <div class="index-namespace-doc">
      The content of this module is based on the MSc Thesis
Coinductive Formalization of SECD Machine in Agda
by Adam KrupiÄka

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Language.Tagless.html">Language.Tagless</a>
    </div>
    <div class="index-namespace-doc">
      This module is based on the paper
Dependent Tagless Final
by Nicoals Biri

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Language.TypeTheory.html">Language.TypeTheory</a>
    </div>
    <div class="index-namespace-doc">
      The content of this module is based on the paper:
A tutorial implementation of a dependently typed lambda calculus
by Andres LÃ¶h, Conor McBride, and Wouter Swierstra

NB: The work is originally written in Haskell and uses unsafe features
    This is not how we would write idiomatic Idris code.
    Cf. Language.IntrinsicScoping.TypeTheory for a more idiomatic representation.

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Search.Auto.html">Search.Auto</a>
    </div>
    <div class="index-namespace-doc">
      The content of this module is based on the paper
Auto in Agda - Programming proof search using reflection
by Wen Kokke and Wouter Swierstra

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Search.Generator.html">Search.Generator</a>
    </div>
    <div class="index-namespace-doc">
      The content of this module is based on the paper
Applications of Applicative Proof Search
by Liam O'Connor
https://doi.org/10.1145/2976022.2976030

The main difference is that we use `Colist1` for the type of
generators rather than `Stream`. This allows us to avoid generating
many duplicates when dealing with finite types which are common in
programming (Bool) but even more so in dependently typed programming
(Vect 0, Fin (S n), etc.).

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Search.HDecidable.html">Search.HDecidable</a>
    </div>
    <div class="index-namespace-doc">
      The content of this module is based on the paper
Applications of Applicative Proof Search
by Liam O'Connor
https://doi.org/10.1145/2976022.2976030

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Search.Negation.html">Search.Negation</a>
    </div>
    <div class="index-namespace-doc">
      
    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Search.Properties.html">Search.Properties</a>
    </div>
    <div class="index-namespace-doc">
      The content of this module is based on the paper
Applications of Applicative Proof Search
by Liam O'Connor
https://doi.org/10.1145/2976022.2976030

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Search.CTL.html">Search.CTL</a>
    </div>
    <div class="index-namespace-doc">
      The content of this module is based on the paper
Applications of Applicative Proof Search
by Liam O'Connor
https://doi.org/10.1145/2976022.2976030

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Search.GCL.html">Search.GCL</a>
    </div>
    <div class="index-namespace-doc">
      The content of this module is based on the paper
Applications of Applicative Proof Search
by Liam O'Connor
https://doi.org/10.1145/2976022.2976030

    </div>
  </div>
</li><li>
  <div class="index-wrapper">
    <div class="index-namespace-url">
      <a class="code" href="docs/Search.Tychonoff.PartI.html">Search.Tychonoff.PartI</a>
    </div>
    <div class="index-namespace-doc">
      This module is based on Todd Waugh Ambridge's blog post series
"Search over uniformly continuous decidable predicates on
infinite collections of types"
https://www.cs.bham.ac.uk/~txw467/tychonoff/

    </div>
  </div>
</li></ul></div><footer>Produced by Idris 2 version 0.7.0-da352d8ed</footer></body></html>