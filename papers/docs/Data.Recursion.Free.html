<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Data.Recursion.Free</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Data.Recursion.Free
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Data.Recursion.Free<span style="float:right">(<a href="../source/Data.Recursion.Free.html">source</a>)</span></h1><pre>Module partially based on McBride&apos;s paper:
Turing-Completeness Totally Free

It gives us a type to describe computation using general recursion
and functions to run these computations for a while or to completion
if we are able to prove them total.

The content of the Erased section is new. Instead of producing the
domain/evaluation pair by computing a Dybjer-Setzer code we build a
specialised structure that allows us to make the domain proof runtime
irrelevant.
</pre></div><code></code><h2>Definitions</h2><dl class="decls"><dt id="Data.Recursion.Free.General"><code><span class="keyword">data</span>&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Syntax for a program using general recursion</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Data.Recursion.Free.Tell"><code><a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.Tell"><span class="name constructor">Tell</span></a>&ensp;:&ensp;<span class="boundvar">x</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  We can return a value without performing any recursive call.</pre></dd>  <dt id="Data.Recursion.Free.Ask"><code><a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.Ask"><span class="name constructor">Ask</span></a>&ensp;:&ensp;(<span class="boundvar">i</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="boundvar">i</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">x</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Or we can pick an input and ask an oracle to give us a return value<br>  for it. The second argument is a continuation explaining what we want<br>  to do with the returned value.</pre></dd></dl><br>  <b>Hints</b>:<br><dl class="decls">  <dt id="$resolved7319"><code><span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;(<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>)</code></dt>  <dt id="$resolved7318"><code><span class="type resolved" title="Prelude.Interfaces.Functor"><span class="name type">Functor</span></span>&ensp;(<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>)</code></dt>  <dt id="$resolved7317"><code><span class="type resolved" title="Prelude.Interfaces.Monad"><span class="name type">Monad</span></span>&ensp;(<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>)</code></dt></dl></dd><dt id="Data.Recursion.Free.PiG"><code><a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.PiG"><span class="name function">PiG</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Type of functions using general recursion</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Recursion.Free.fold"><code><a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.fold"><span class="name function">fold</span></a>&ensp;:&ensp;(<span class="boundvar">x</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">y</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;((<span class="boundvar">i</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="boundvar">i</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">y</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">y</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">x</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">y</span></code></dt><dd><pre>  Recursor for General</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Recursion.Free.call"><code><a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.call"><span class="name function">call</span></a>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.PiG"><span class="name function">PiG</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Perform a recursive call and return the value provided by the oracle.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Recursion.Free.bind"><code><a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.bind"><span class="name function">bind</span></a>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">x</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">x</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">y</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">y</span></code></dt><dd><pre>  Monadic bind (defined outside of the interface to be able to use it for<br>  map and (&lt;*&gt;)).</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Recursion.Free.monadMorphism"><code><a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.monadMorphism"><span class="name function">monadMorphism</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Monad"><span class="name type">Monad</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;((<span class="boundvar">i</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="boundvar">i</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">x</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Given a monadic oracle we can give a monad morphism interpreting a<br>  function using general recursion as a monadic process.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Recursion.Free.already"><code><a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.already"><span class="name function">already</span></a>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">x</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Check whether we are ready to return a value</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Recursion.Free.expand"><code><a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.expand"><span class="name function">expand</span></a>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.PiG"><span class="name function">PiG</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">x</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Use a function using general recursion to expand all of the oracle calls.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Recursion.Free.engine"><code><a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.engine"><span class="name function">engine</span></a>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.PiG"><span class="name function">PiG</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">x</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Recursively call expand a set number of times.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Recursion.Free.petrol"><code><a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.petrol"><span class="name function">petrol</span></a>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.PiG"><span class="name function">PiG</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">i</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="boundvar">i</span>)</code></dt><dd><pre>  Check whether recursively calling expand a set number of times is enough<br>  to produce a value.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Recursion.Free.late"><code><a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.late"><span class="name function">late</span></a>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.PiG"><span class="name function">PiG</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">x</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Late.Late"><span class="name type">Late</span></span>&ensp;<span class="boundvar">x</span></code></dt><dd><pre>  Rely on an oracle using general recursion to convert a function using<br>  general recursion into a process returning a value in the (distant) future.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Recursion.Free.lazy"><code><a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.lazy"><span class="name function">lazy</span></a>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.PiG"><span class="name function">PiG</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">i</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Late.Late"><span class="name type">Late</span></span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="boundvar">i</span>)</code></dt><dd><pre>  Interpret a function using general recursion as a process returning<br>  a value in the (distant) future.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Recursion.Free.DybjerSetzer.Domain"><code><span class="type resolved" title="Data.Recursion.Free.DybjerSetzer.Domain"><span class="name function">Domain</span></span>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.PiG"><span class="name function">PiG</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">i</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.InductionRecursion.DybjerSetzer.html#Data.InductionRecursion.DybjerSetzer.Code"><span class="name type">Code</span></a>&ensp;<span class="boundvar">b</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="boundvar">i</span>)</code></dt><dd><pre>  Compute, as a Dybjer-Setzer code for an inductive-recursive type, the domain<br>  of a function defined by general recursion.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Recursion.Free.DybjerSetzer.evaluate"><code><span class="type resolved" title="Data.Recursion.Free.DybjerSetzer.evaluate"><span class="name function">evaluate</span></span>&ensp;:&ensp;(<span class="boundvar">f</span>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.PiG"><span class="name function">PiG</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">i</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.InductionRecursion.DybjerSetzer.html#Data.InductionRecursion.DybjerSetzer.Mu"><span class="name type">Mu</span></a>&ensp;(<span class="type resolved" title="Data.Recursion.Free.DybjerSetzer.Domain"><span class="name function">Domain</span></span>&ensp;<span class="boundvar">f</span>)&ensp;<span class="boundvar">i</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">i</span></code></dt><dd><pre>  If a given input is in the domain of the function then we may evaluate<br>  it fully on that input and obtain a pure return value.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Recursion.Free.DybjerSetzer.totally"><code><span class="type resolved" title="Data.Recursion.Free.DybjerSetzer.totally"><span class="name function">totally</span></span>&ensp;:&ensp;(<span class="boundvar">f</span>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.PiG"><span class="name function">PiG</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;((<span class="boundvar">i</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.InductionRecursion.DybjerSetzer.html#Data.InductionRecursion.DybjerSetzer.Mu"><span class="name type">Mu</span></a>&ensp;(<span class="type resolved" title="Data.Recursion.Free.DybjerSetzer.Domain"><span class="name function">Domain</span></span>&ensp;<span class="boundvar">f</span>)&ensp;<span class="boundvar">i</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">i</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">i</span></code></dt><dd><pre>  If every input value is in the domain then the function is total.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Recursion.Free.Erased.Layer"><code><span class="keyword">data</span>&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.Layer"><span class="name type">Layer</span></span>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.PiG"><span class="name function">PiG</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="boundvar">i</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Data.Recursion.Free.Erased.MkTell"><code><span class="type resolved" title="Data.Recursion.Free.Erased.MkTell"><span class="name constructor">MkTell</span></span>&ensp;:&ensp;(<span class="boundvar">o</span>&ensp;:&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">i</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.Layer"><span class="name type">Layer</span></span>&ensp;<span class="boundvar">f</span>&ensp;(<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.Tell"><span class="name constructor">Tell</span></a>&ensp;<span class="boundvar">o</span>)</code></dt><dd><pre>  A computation returning a value is trivially terminating</pre></dd>  <dt id="Data.Recursion.Free.Erased.MkAsk"><code><span class="type resolved" title="Data.Recursion.Free.Erased.MkAsk"><span class="name constructor">MkAsk</span></span>&ensp;:&ensp;(<span class="boundvar">j</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">jprf</span>&ensp;:&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.Domain"><span class="name function">Domain</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">j</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;:&ensp;(<span class="boundvar">b</span>&ensp;<span class="boundvar">j</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="boundvar">i</span>)))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.Layer"><span class="name type">Layer</span></span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Data.Recursion.Free.Erased.evaluate"><span class="name function">evaluate</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">j</span>&ensp;<span class="boundvar">jprf</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.Layer"><span class="name type">Layer</span></span>&ensp;<span class="boundvar">f</span>&ensp;(<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.Ask"><span class="name constructor">Ask</span></a>&ensp;<span class="boundvar">j</span>&ensp;<span class="boundvar">k</span>)</code></dt><dd><pre>  Performing a call to the oracle is termnating if the input is in its<br>  domain and if the rest of the computation is also finite.</pre></dd></dl></dd><dt id="Data.Recursion.Free.Erased.view"><code><span class="type resolved" title="Data.Recursion.Free.Erased.view"><span class="name function">view</span></span>&ensp;:&ensp;(<span class="boundvar">d</span>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="boundvar">i</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">l</span>&ensp;:&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.Layer"><span class="name type">Layer</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">d</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.View"><span class="name type">View</span></span>&ensp;<span class="boundvar">l</span></code></dt><dd><pre>  Function computing the view by pattern-matching on the computation and<br>  inverting the proof. Note that the proof is runtime irrelevant even though<br>  the resulting view is not: this is possible because the relevant constructor<br>  is uniquely determined by the shape of `d`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Recursion.Free.Erased.totally"><code><span class="type resolved" title="Data.Recursion.Free.Erased.totally"><span class="name function">totally</span></span>&ensp;:&ensp;(<span class="boundvar">f</span>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.PiG"><span class="name function">PiG</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;((<span class="boundvar">i</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.Domain"><span class="name function">Domain</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">i</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">i</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">i</span></code></dt><dd><pre>  If a function&apos;s domain is total then it is a pure function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Recursion.Free.Erased.irrelevantDomain"><code><span class="type resolved" title="Data.Recursion.Free.Erased.irrelevantDomain"><span class="name function">irrelevantDomain</span></span>&ensp;:&ensp;(<span class="boundvar">f</span>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.PiG"><span class="name function">PiG</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">i</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">p</span>&ensp;:&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.Domain"><span class="name function">Domain</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">i</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">q</span>&ensp;:&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.Domain"><span class="name function">Domain</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">i</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">q</span></code></dt><dd><pre>  Domain is a singleton type</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Recursion.Free.Erased.evaluateLayerIrrelevance"><code><span class="type resolved" title="Data.Recursion.Free.Erased.evaluateLayerIrrelevance"><span class="name function">evaluateLayerIrrelevance</span></span>&ensp;:&ensp;(<span class="boundvar">f</span>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.PiG"><span class="name function">PiG</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">d</span>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.General"><span class="name type">General</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;(<span class="boundvar">b</span>&ensp;<span class="boundvar">i</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">p</span>&ensp;:&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.Layer"><span class="name type">Layer</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">d</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">q</span>&ensp;:&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.Layer"><span class="name type">Layer</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">d</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.evaluateLayer"><span class="name function">evaluateLayer</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">d</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.evaluateLayer"><span class="name function">evaluateLayer</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">d</span>&ensp;<span class="boundvar">q</span></code></dt><dd><pre>  The result of `evaluateLayer` does not depend on the specific proof that<br>  `i` is in the domain of the layer of computation at hand.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Recursion.Free.Erased.evaluateIrrelevance"><code><span class="type resolved" title="Data.Recursion.Free.Erased.evaluateIrrelevance"><span class="name function">evaluateIrrelevance</span></span>&ensp;:&ensp;(<span class="boundvar">f</span>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.PiG"><span class="name function">PiG</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">i</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">p</span>&ensp;:&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.Domain"><span class="name function">Domain</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">i</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">q</span>&ensp;:&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.Domain"><span class="name function">Domain</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">i</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.evaluate"><span class="name function">evaluate</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">i</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.evaluate"><span class="name function">evaluate</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">i</span>&ensp;<span class="boundvar">q</span></code></dt><dd><pre>  The result of `evaluate` does not depend on the specific proof that `i`<br>  is in the domain of the function at hand.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Recursion.Free.Erased.totallyIrrelevance"><code><span class="type resolved" title="Data.Recursion.Free.Erased.totallyIrrelevance"><span class="name function">totallyIrrelevance</span></span>&ensp;:&ensp;(<span class="boundvar">f</span>&ensp;:&ensp;<a class="type" href="Data.Recursion.Free.html#Data.Recursion.Free.PiG"><span class="name function">PiG</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">p</span>&ensp;:&ensp;((<span class="boundvar">i</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.Domain"><span class="name function">Domain</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">i</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">q</span>&ensp;:&ensp;((<span class="boundvar">i</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.Domain"><span class="name function">Domain</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">i</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">i</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.totally"><span class="name function">totally</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">i</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Data.Recursion.Free.Erased.totally"><span class="name function">totally</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">i</span></code></dt><dd><pre>  The result computed by a total function is independent from the proof<br>  that it is total.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.7.0-6c6ee58eb</footer></body></html>