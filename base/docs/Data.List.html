<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Data.List</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Data.List
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Data.List<span style="float:right">(<a href="../source/Data.List.html">source</a>)</span></h1><pre></pre></div><h2>Reexports</h2><code><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Control.Function<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.Zippable</code><h2>Definitions</h2><dl class="decls"><dt id="Data.List.isNil"><code><a class="type" href="Data.List.html#Data.List.isNil"><span class="name function">isNil</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Boolean&ensp;check&ensp;for&ensp;whether&ensp;the&ensp;list&ensp;is&ensp;the&ensp;empty&ensp;list.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.isCons"><code><a class="type" href="Data.List.html#Data.List.isCons"><span class="name function">isCons</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Boolean&ensp;check&ensp;for&ensp;whether&ensp;the&ensp;list&ensp;contains&ensp;a&ensp;cons&ensp;(::)&ensp;/&ensp;is&ensp;non-empty.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.snoc"><code><a class="type" href="Data.List.html#Data.List.snoc"><span class="name function">snoc</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Add&ensp;an&ensp;element&ensp;to&ensp;the&ensp;end&ensp;of&ensp;a&ensp;list.<br>  O(n).&ensp;See&ensp;the&ensp;`Data.SnocList`&ensp;module&ensp;if&ensp;you&ensp;need&ensp;to&ensp;perform&ensp;`snoc`&ensp;often.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.take"><code><a class="type" href="Data.List.html#Data.List.take"><span class="name function">take</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Take&ensp;`n`&ensp;first&ensp;elements&ensp;from&ensp;`xs`,&ensp;returning&ensp;the&ensp;whole&ensp;list&ensp;if<br>  `n`&ensp;&gt;=&ensp;length&ensp;`xs`.<br>  <br>  @&ensp;n&ensp;the&ensp;number&ensp;of&ensp;elements&ensp;to&ensp;take<br>  @&ensp;xs&ensp;the&ensp;list&ensp;to&ensp;take&ensp;the&ensp;elements&ensp;from</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.drop"><code><a class="type" href="Data.List.html#Data.List.drop"><span class="name function">drop</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Remove&ensp;`n`&ensp;first&ensp;elements&ensp;from&ensp;`xs`,&ensp;returning&ensp;the&ensp;empty&ensp;list&ensp;if<br>  `n&ensp;&gt;=&ensp;length&ensp;xs`<br>  <br>  @&ensp;n&ensp;the&ensp;number&ensp;of&ensp;elements&ensp;to&ensp;remove<br>  @&ensp;xs&ensp;the&ensp;list&ensp;to&ensp;drop&ensp;the&ensp;elements&ensp;from</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.InBounds"><code><span class="keyword">data</span>&ensp;<a class="type" href="Data.List.html#Data.List.InBounds"><span class="name type">InBounds</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Satisfiable&ensp;if&ensp;`k`&ensp;is&ensp;a&ensp;valid&ensp;index&ensp;into&ensp;`xs`.<br>  <br>  @&ensp;k&ensp;the&ensp;potential&ensp;index<br>  @&ensp;xs&ensp;the&ensp;list&ensp;into&ensp;which&ensp;k&ensp;may&ensp;be&ensp;an&ensp;index</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Data.List.InFirst"><code><a class="type" href="Data.List.html#Data.List.InFirst"><span class="name constructor">InFirst</span></a>&ensp;:&ensp;<a class="type" href="Data.List.html#Data.List.InBounds"><span class="name type">InBounds</span></a>&ensp;<span class="name constructor">0</span>&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">xs</span>)</code></dt><dd><pre>  Z&ensp;is&ensp;a&ensp;valid&ensp;index&ensp;into&ensp;any&ensp;cons&ensp;cell</pre></dd>  <dt id="Data.List.InLater"><code><a class="type" href="Data.List.html#Data.List.InLater"><span class="name constructor">InLater</span></a>&ensp;:&ensp;<a class="type" href="Data.List.html#Data.List.InBounds"><span class="name type">InBounds</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">xs</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.List.html#Data.List.InBounds"><span class="name type">InBounds</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">k</span>)&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">xs</span>)</code></dt><dd><pre>  Valid&ensp;indices&ensp;can&ensp;be&ensp;extended</pre></dd></dl><br>  <b>Hints</b>:<br><dl class="decls">  <dt id="$resolved4331"><code><span class="type resolved" title="Prelude.Uninhabited.Uninhabited"><span class="name type">Uninhabited</span></span>&ensp;(<a class="type" href="Data.List.html#Data.List.InBounds"><span class="name type">InBounds</span></a>&ensp;<span class="boundvar">k</span>&ensp;[])</code></dt>  <dt id="$resolved4330"><code><span class="type resolved" title="Prelude.Uninhabited.Uninhabited"><span class="name type">Uninhabited</span></span>&ensp;(<a class="type" href="Data.List.html#Data.List.InBounds"><span class="name type">InBounds</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">xs</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Uninhabited.Uninhabited"><span class="name type">Uninhabited</span></span>&ensp;(<a class="type" href="Data.List.html#Data.List.InBounds"><span class="name type">InBounds</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">k</span>)&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">xs</span>))</code></dt></dl></dd><dt id="Data.List.inBounds"><code><a class="type" href="Data.List.html#Data.List.inBounds"><span class="name function">inBounds</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">xs</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Dec"><span class="name type">Dec</span></span>&ensp;(<a class="type" href="Data.List.html#Data.List.InBounds"><span class="name type">InBounds</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">xs</span>)</code></dt><dd><pre>  Decide&ensp;whether&ensp;`k`&ensp;is&ensp;a&ensp;valid&ensp;index&ensp;into&ensp;`xs`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.index"><code><a class="type" href="Data.List.html#Data.List.index"><span class="name function">index</span></a>&ensp;:&ensp;(<span class="boundvar">n</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">xs</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Data.List.html#Data.List.InBounds"><span class="name type">InBounds</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">xs</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Find&ensp;a&ensp;particular&ensp;element&ensp;of&ensp;a&ensp;list.<br>  <br>  @&ensp;ok&ensp;a&ensp;proof&ensp;that&ensp;the&ensp;index&ensp;is&ensp;within&ensp;bounds</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.index&apos;"><code><a class="type" href="Data.List.html#Data.List.index&apos;"><span class="name function">index&apos;</span></a>&ensp;:&ensp;(<span class="boundvar">xs</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Fin.html#Data.Fin.Fin"><span class="name type">Fin</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">xs</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.iterate"><code><a class="type" href="Data.List.html#Data.List.iterate"><span class="name function">iterate</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Generate&ensp;a&ensp;list&ensp;by&ensp;repeatedly&ensp;applying&ensp;a&ensp;partial&ensp;function&ensp;until&ensp;exhausted.<br>  @&ensp;f&ensp;the&ensp;function&ensp;to&ensp;iterate<br>  @&ensp;x&ensp;the&ensp;initial&ensp;value&ensp;that&ensp;will&ensp;be&ensp;the&ensp;head&ensp;of&ensp;the&ensp;list</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.unfoldr"><code><a class="type" href="Data.List.html#Data.List.unfoldr"><span class="name function">unfoldr</span></a>&ensp;:&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">a</span>,&ensp;<span class="boundvar">b</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Given&ensp;a&ensp;function&ensp;`f`&ensp;which&ensp;extracts&ensp;an&ensp;element&ensp;of&ensp;`b`&ensp;and&ensp;`b`&apos;s<br>  continuation,&ensp;return&ensp;the&ensp;list&ensp;consisting&ensp;of&ensp;the&ensp;extracted&ensp;elements.<br>  CAUTION:&ensp;Only&ensp;terminates&ensp;if&ensp;`f`&ensp;eventually&ensp;returns&ensp;`Nothing`.<br>  <br>  @&ensp;f&ensp;a&ensp;function&ensp;which&ensp;provides&ensp;an&ensp;element&ensp;of&ensp;`b`&ensp;and&ensp;the&ensp;rest&ensp;of&ensp;`b`<br>  @&ensp;b&ensp;a&ensp;structure&ensp;contanining&ensp;any&ensp;number&ensp;of&ensp;elements</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.iterateN"><code><a class="type" href="Data.List.html#Data.List.iterateN"><span class="name function">iterateN</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Returns&ensp;the&ensp;list&ensp;of&ensp;elements&ensp;obtained&ensp;by&ensp;applying&ensp;`f`&ensp;to&ensp;`x`&ensp;`0`&ensp;to&ensp;`n-1`&ensp;times,<br>  starting&ensp;with&ensp;`x`.<br>  <br>  @&ensp;n&ensp;the&ensp;number&ensp;of&ensp;times&ensp;to&ensp;iterate&ensp;`f`&ensp;over&ensp;`x`<br>  @&ensp;f&ensp;a&ensp;function&ensp;producing&ensp;a&ensp;series<br>  @&ensp;x&ensp;the&ensp;initial&ensp;element&ensp;of&ensp;the&ensp;series</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.takeWhile"><code><a class="type" href="Data.List.html#Data.List.takeWhile"><span class="name function">takeWhile</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Get&ensp;the&ensp;longest&ensp;prefix&ensp;of&ensp;the&ensp;list&ensp;that&ensp;satisfies&ensp;the&ensp;predicate.<br>  <br>  @&ensp;p&ensp;a&ensp;custom&ensp;predicate&ensp;for&ensp;the&ensp;elements&ensp;of&ensp;the&ensp;list<br>  @&ensp;xs&ensp;the&ensp;list&ensp;of&ensp;elements</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.dropWhile"><code><a class="type" href="Data.List.html#Data.List.dropWhile"><span class="name function">dropWhile</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Remove&ensp;elements&ensp;from&ensp;the&ensp;list&ensp;until&ensp;an&ensp;element&ensp;no&ensp;longer&ensp;satisfies&ensp;the<br>  predicate.<br>  <br>  @&ensp;p&ensp;a&ensp;custom&ensp;predicate&ensp;for&ensp;the&ensp;elements&ensp;of&ensp;the&ensp;list<br>  @&ensp;xs&ensp;the&ensp;list&ensp;of&ensp;elements&ensp;to&ensp;remove&ensp;from</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.find"><code><a class="type" href="Data.List.html#Data.List.find"><span class="name function">find</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Find&ensp;the&ensp;first&ensp;element&ensp;of&ensp;the&ensp;list&ensp;that&ensp;satisfies&ensp;the&ensp;predicate.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.findIndex"><code><a class="type" href="Data.List.html#Data.List.findIndex"><span class="name function">findIndex</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">xs</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<a class="type" href="Data.Fin.html#Data.Fin.Fin"><span class="name type">Fin</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">xs</span>))</code></dt><dd><pre>  Find&ensp;the&ensp;index&ensp;and&ensp;proof&ensp;of&ensp;InBounds&ensp;of&ensp;the&ensp;first&ensp;element&ensp;(if&ensp;exists)&ensp;of&ensp;a<br>  list&ensp;that&ensp;satisfies&ensp;the&ensp;given&ensp;test,&ensp;else&ensp;`Nothing`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.findIndices"><code><a class="type" href="Data.List.html#Data.List.findIndices"><span class="name function">findIndices</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Find&ensp;indices&ensp;of&ensp;all&ensp;elements&ensp;that&ensp;satisfy&ensp;the&ensp;given&ensp;test.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.lookupBy"><code><a class="type" href="Data.List.html#Data.List.lookupBy"><span class="name function">lookupBy</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="boundvar">b</span>,&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Find&ensp;associated&ensp;information&ensp;in&ensp;a&ensp;list&ensp;using&ensp;a&ensp;custom&ensp;comparison.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.lookup"><code><a class="type" href="Data.List.html#Data.List.lookup"><span class="name function">lookup</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="boundvar">a</span>,&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Find&ensp;associated&ensp;information&ensp;in&ensp;a&ensp;list&ensp;using&ensp;Boolean&ensp;equality.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.nubBy"><code><a class="type" href="Data.List.html#Data.List.nubBy"><span class="name function">nubBy</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Remove&ensp;duplicate&ensp;elements&ensp;from&ensp;a&ensp;list&ensp;using&ensp;a&ensp;custom&ensp;comparison.&ensp;The&ensp;general<br>  case&ensp;of&ensp;`nub`.<br>  O(n^2).<br>  <br>  @&ensp;p&ensp;a&ensp;custom&ensp;comparison&ensp;for&ensp;detecting&ensp;duplicate&ensp;elements<br>  @&ensp;xs&ensp;the&ensp;list&ensp;to&ensp;remove&ensp;the&ensp;duplicates&ensp;from</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.nub"><code><a class="type" href="Data.List.html#Data.List.nub"><span class="name function">nub</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  The&ensp;nub&ensp;function&ensp;removes&ensp;duplicate&ensp;elements&ensp;from&ensp;a&ensp;list&ensp;using<br>  boolean&ensp;equality.&ensp;In&ensp;particular,&ensp;it&ensp;keeps&ensp;only&ensp;the&ensp;first&ensp;occurrence&ensp;of&ensp;each<br>  element.&ensp;It&ensp;is&ensp;a&ensp;special&ensp;case&ensp;of&ensp;`nubBy`,&ensp;which&ensp;allows&ensp;the&ensp;programmer&ensp;to<br>  supply&ensp;their&ensp;own&ensp;equality&ensp;test.<br>  O(n^2).<br>  <br>  ```idris&ensp;example<br>  nub&ensp;(the&ensp;(List&ensp;_)&ensp;[1,2,1,3])<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.insertAt"><code><a class="type" href="Data.List.html#Data.List.insertAt"><span class="name function">insertAt</span></a>&ensp;:&ensp;(<span class="boundvar">idx</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">xs</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Data.Nat.html#Data.Nat.LTE"><span class="name type">LTE</span></a>&ensp;<span class="boundvar">idx</span>&ensp;(<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">xs</span>)}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Insert&ensp;an&ensp;element&ensp;at&ensp;a&ensp;particular&ensp;index.<br>  <br>  ```idris&ensp;example<br>  insertAt&ensp;1&ensp;[6,&ensp;8,&ensp;9]&ensp;7<br>  ```<br>  <br>  @idx&ensp;The&ensp;index&ensp;of&ensp;the&ensp;inserted&ensp;value&ensp;in&ensp;the&ensp;resulting&ensp;list.<br>  @x&ensp;The&ensp;value&ensp;to&ensp;insert.<br>  @xs&ensp;The&ensp;list&ensp;to&ensp;insert&ensp;the&ensp;value&ensp;into.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.deleteAt"><code><a class="type" href="Data.List.html#Data.List.deleteAt"><span class="name function">deleteAt</span></a>&ensp;:&ensp;(<span class="boundvar">idx</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">xs</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Data.List.html#Data.List.InBounds"><span class="name type">InBounds</span></a>&ensp;<span class="boundvar">idx</span>&ensp;<span class="boundvar">xs</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Construct&ensp;a&ensp;new&ensp;list&ensp;consisting&ensp;of&ensp;all&ensp;but&ensp;the&ensp;indicated&ensp;element.<br>  <br>  ```idris&ensp;example<br>  deleteAt&ensp;3&ensp;[5,&ensp;6,&ensp;7,&ensp;8,&ensp;9]<br>  ```<br>  <br>  @&ensp;idx&ensp;The&ensp;index&ensp;of&ensp;the&ensp;value&ensp;to&ensp;delete.<br>  @&ensp;xs&ensp;The&ensp;list&ensp;to&ensp;delete&ensp;the&ensp;value&ensp;from.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.deleteBy"><code><a class="type" href="Data.List.html#Data.List.deleteBy"><span class="name function">deleteBy</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  The&ensp;deleteBy&ensp;function&ensp;behaves&ensp;like&ensp;delete,&ensp;but&ensp;takes&ensp;a&ensp;user-supplied&ensp;equality&ensp;predicate.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.delete"><code><a class="type" href="Data.List.html#Data.List.delete"><span class="name function">delete</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  `delete&ensp;x`&ensp;removes&ensp;the&ensp;first&ensp;occurrence&ensp;of&ensp;`x`&ensp;from&ensp;its&ensp;list&ensp;argument.&ensp;For<br>  example,<br>  <br>  ````idris&ensp;example<br>  delete&ensp;&apos;a&apos;&ensp;[&apos;b&apos;,&ensp;&apos;a&apos;,&ensp;&apos;n&apos;,&ensp;&apos;a&apos;,&ensp;&apos;n&apos;,&ensp;&apos;a&apos;]<br>  ````<br>  <br>  It&ensp;is&ensp;a&ensp;special&ensp;case&ensp;of&ensp;deleteBy,&ensp;which&ensp;allows&ensp;the&ensp;programmer&ensp;to&ensp;supply<br>  their&ensp;own&ensp;equality&ensp;test.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.deleteFirstsBy"><code><a class="type" href="Data.List.html#Data.List.deleteFirstsBy"><span class="name function">deleteFirstsBy</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Delete&ensp;the&ensp;first&ensp;occurrence&ensp;of&ensp;each&ensp;element&ensp;from&ensp;the&ensp;second&ensp;list&ensp;in&ensp;the&ensp;first<br>  list&ensp;where&ensp;equality&ensp;is&ensp;determined&ensp;by&ensp;the&ensp;predicate&ensp;passed&ensp;as&ensp;the&ensp;first&ensp;argument.<br>  @&ensp;p&ensp;A&ensp;function&ensp;that&ensp;returns&ensp;true&ensp;when&ensp;its&ensp;two&ensp;arguments&ensp;should&ensp;be&ensp;considered&ensp;equal.<br>  @&ensp;source&ensp;The&ensp;list&ensp;to&ensp;delete&ensp;elements&ensp;from.<br>  @&ensp;undesirables&ensp;The&ensp;list&ensp;of&ensp;elements&ensp;to&ensp;delete.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.\\"><code><a class="type" href="Data.List.html#Data.List.\\"><span class="name function">(\\)</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  The&ensp;non-associative&ensp;list-difference.<br>  A&ensp;specialized&ensp;form&ensp;of&ensp;@deleteFirstsBy@&ensp;where&ensp;the&ensp;predicate&ensp;is&ensp;equality&ensp;under&ensp;the&ensp;@Eq@<br>  interface.<br>  Deletes&ensp;the&ensp;first&ensp;occurrence&ensp;of&ensp;each&ensp;element&ensp;of&ensp;the&ensp;second&ensp;list&ensp;from&ensp;the&ensp;first&ensp;list.<br>  <br>  In&ensp;the&ensp;following&ensp;example,&ensp;the&ensp;result&ensp;is&ensp;`[2,&ensp;4]`.<br>  ```idris&ensp;example<br>  [1,&ensp;2,&ensp;3,&ensp;4]&ensp;//&ensp;[1,&ensp;3]<br>  ```<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;7</dd><dt id="Data.List.unionBy"><code><a class="type" href="Data.List.html#Data.List.unionBy"><span class="name function">unionBy</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  The&ensp;unionBy&ensp;function&ensp;returns&ensp;the&ensp;union&ensp;of&ensp;two&ensp;lists&ensp;by&ensp;user-supplied&ensp;equality&ensp;predicate.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.union"><code><a class="type" href="Data.List.html#Data.List.union"><span class="name function">union</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Compute&ensp;the&ensp;union&ensp;of&ensp;two&ensp;lists&ensp;according&ensp;to&ensp;their&ensp;`Eq`&ensp;implementation.<br>  <br>  ```idris&ensp;example<br>  union&ensp;[&apos;d&apos;,&ensp;&apos;o&apos;,&ensp;&apos;g&apos;]&ensp;[&apos;c&apos;,&ensp;&apos;o&apos;,&ensp;&apos;w&apos;]<br>  ```<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.spanBy"><code><a class="type" href="Data.List.html#Data.List.spanBy"><span class="name function">spanBy</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">b</span>,&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Like&ensp;@span@&ensp;but&ensp;using&ensp;a&ensp;predicate&ensp;that&ensp;might&ensp;convert&ensp;a&ensp;to&ensp;b,&ensp;i.e.&ensp;given&ensp;a<br>  predicate&ensp;from&ensp;a&ensp;to&ensp;Maybe&ensp;b&ensp;and&ensp;a&ensp;list&ensp;of&ensp;as,&ensp;returns&ensp;a&ensp;tuple&ensp;consisting&ensp;of<br>  the&ensp;longest&ensp;prefix&ensp;of&ensp;the&ensp;list&ensp;where&ensp;a&ensp;-&gt;&ensp;Just&ensp;b,&ensp;and&ensp;the&ensp;rest&ensp;of&ensp;the&ensp;list.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.span"><code><a class="type" href="Data.List.html#Data.List.span"><span class="name function">span</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>,&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Given&ensp;a&ensp;predicate&ensp;and&ensp;a&ensp;list,&ensp;returns&ensp;a&ensp;tuple&ensp;consisting&ensp;of&ensp;the&ensp;longest<br>  prefix&ensp;of&ensp;the&ensp;list&ensp;whose&ensp;elements&ensp;satisfy&ensp;the&ensp;predicate,&ensp;and&ensp;the&ensp;rest&ensp;of&ensp;the<br>  list.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.break"><code><a class="type" href="Data.List.html#Data.List.break"><span class="name function">break</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>,&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Similar&ensp;to&ensp;`span`&ensp;but&ensp;negates&ensp;the&ensp;predicate,&ensp;i.e.:&ensp;returns&ensp;a&ensp;tuple<br>  consisting&ensp;of&ensp;the&ensp;longest&ensp;prefix&ensp;of&ensp;the&ensp;list&ensp;whose&ensp;elements&ensp;don&apos;t&ensp;satisfy<br>  the&ensp;predicate,&ensp;and&ensp;the&ensp;rest&ensp;of&ensp;the&ensp;list.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.singleton"><code><a class="type" href="Data.List.html#Data.List.singleton"><span class="name function">singleton</span></a>&ensp;:&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.split"><code><a class="type" href="Data.List.html#Data.List.split"><span class="name function">split</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.List1.html#Data.List1.List1"><span class="name type">List1</span></a>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.splitAt"><code><a class="type" href="Data.List.html#Data.List.splitAt"><span class="name function">splitAt</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>,&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Split&ensp;the&ensp;list&ensp;`xs`&ensp;at&ensp;the&ensp;index&ensp;`n`.&ensp;If&ensp;`n&ensp;>&ensp;length&ensp;xs`,&ensp;returns&ensp;a&ensp;tuple<br>  consisting&ensp;of&ensp;`xs`&ensp;and&ensp;`[]`.<br>  <br>  @&ensp;n&ensp;the&ensp;index&ensp;to&ensp;split&ensp;the&ensp;list&ensp;at<br>  @&ensp;xs&ensp;the&ensp;list&ensp;to&ensp;split</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.partition"><code><a class="type" href="Data.List.html#Data.List.partition"><span class="name function">partition</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>,&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Divide&ensp;the&ensp;list&ensp;into&ensp;a&ensp;tuple&ensp;containing&ensp;two&ensp;smaller&ensp;lists:&ensp;one&ensp;with&ensp;the<br>  elements&ensp;that&ensp;satisfies&ensp;the&ensp;given&ensp;predicate&ensp;and&ensp;another&ensp;with&ensp;the&ensp;elements<br>  that&ensp;don&apos;t.<br>  <br>  @&ensp;p&ensp;the&ensp;predicate&ensp;to&ensp;partition&ensp;according&ensp;to<br>  @&ensp;xs&ensp;the&ensp;list&ensp;to&ensp;partition</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.inits"><code><a class="type" href="Data.List.html#Data.List.inits"><span class="name function">inits</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  The&ensp;inits&ensp;function&ensp;returns&ensp;all&ensp;initial&ensp;segments&ensp;of&ensp;the&ensp;argument,&ensp;shortest<br>  first.&ensp;For&ensp;example,<br>  <br>  ```idris&ensp;example<br>  inits&ensp;[1,2,3]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.tails"><code><a class="type" href="Data.List.html#Data.List.tails"><span class="name function">tails</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  The&ensp;tails&ensp;function&ensp;returns&ensp;all&ensp;final&ensp;segments&ensp;of&ensp;the&ensp;argument,&ensp;longest<br>  first.&ensp;For&ensp;example,<br>  <br>  ```idris&ensp;example<br>  tails&ensp;[1,2,3]&ensp;==&ensp;[[1,2,3],&ensp;[2,3],&ensp;[3],&ensp;[]]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.splitOn"><code><a class="type" href="Data.List.html#Data.List.splitOn"><span class="name function">splitOn</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.List1.html#Data.List1.List1"><span class="name type">List1</span></a>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Split&ensp;on&ensp;the&ensp;given&ensp;element.<br>  <br>  ```idris&ensp;example<br>  splitOn&ensp;0&ensp;[1,0,2,0,0,3]<br>  ```<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.replaceAt"><code><a class="type" href="Data.List.html#Data.List.replaceAt"><span class="name function">replaceAt</span></a>&ensp;:&ensp;(<span class="boundvar">idx</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">xs</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Data.List.html#Data.List.InBounds"><span class="name type">InBounds</span></a>&ensp;<span class="boundvar">idx</span>&ensp;<span class="boundvar">xs</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Replace&ensp;an&ensp;element&ensp;at&ensp;a&ensp;particlar&ensp;index&ensp;with&ensp;another.<br>  <br>  ```idris&ensp;example<br>  replaceAt&ensp;2&ensp;6&ensp;[1,&ensp;2,&ensp;3,&ensp;4]<br>  ```<br>  <br>  @idx&ensp;The&ensp;index&ensp;of&ensp;the&ensp;value&ensp;to&ensp;replace.<br>  @x&ensp;The&ensp;value&ensp;to&ensp;insert.<br>  @xs&ensp;The&ensp;list&ensp;in&ensp;which&ensp;to&ensp;replace&ensp;an&ensp;element.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.replaceWhen"><code><a class="type" href="Data.List.html#Data.List.replaceWhen"><span class="name function">replaceWhen</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Replace&ensp;the&ensp;elements&ensp;in&ensp;the&ensp;list&ensp;that&ensp;satisfy&ensp;the&ensp;predicate&ensp;with&ensp;the&ensp;given<br>  value.&ensp;The&ensp;general&ensp;case&ensp;of&ensp;`replaceOn`.<br>  <br>  @&ensp;p&ensp;the&ensp;predicate&ensp;to&ensp;replace&ensp;elements&ensp;in&ensp;the&ensp;list&ensp;according&ensp;to<br>  @&ensp;b&ensp;the&ensp;element&ensp;to&ensp;replace&ensp;with<br>  @&ensp;l&ensp;the&ensp;list&ensp;to&ensp;perform&ensp;the&ensp;replacements&ensp;on</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.replaceOn"><code><a class="type" href="Data.List.html#Data.List.replaceOn"><span class="name function">replaceOn</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Replace&ensp;the&ensp;elements&ensp;in&ensp;the&ensp;list&ensp;that&ensp;are&ensp;equal&ensp;to&ensp;`e`,&ensp;using&ensp;boolean<br>  equality,&ensp;with&ensp;`b`.&ensp;A&ensp;special&ensp;case&ensp;of&ensp;`replaceWhen`,&ensp;using&ensp;`==&ensp;e`&ensp;as&ensp;the<br>  predicate.<br>  <br>  ```idris&ensp;example<br>  >&ensp;replaceOn&ensp;&apos;-&apos;&ensp;&apos;,&apos;&ensp;[&apos;1&apos;,&ensp;&apos;-&apos;,&ensp;&apos;2&apos;,&ensp;&apos;-&apos;,&ensp;&apos;3&apos;]<br>  [&apos;1&apos;,&ensp;&apos;,&apos;,&ensp;&apos;2&apos;,&ensp;&apos;,&apos;,&ensp;&apos;3&apos;]<br>  ```<br>  <br>  @&ensp;e&ensp;the&ensp;element&ensp;to&ensp;find&ensp;and&ensp;replace<br>  @&ensp;b&ensp;the&ensp;element&ensp;to&ensp;replace&ensp;with<br>  @&ensp;l&ensp;the&ensp;list&ensp;to&ensp;perform&ensp;the&ensp;replacements&ensp;on</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.replicate"><code><a class="type" href="Data.List.html#Data.List.replicate"><span class="name function">replicate</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Construct&ensp;a&ensp;list&ensp;with&ensp;`n`&ensp;copies&ensp;of&ensp;`x`.<br>  <br>  @&ensp;n&ensp;how&ensp;many&ensp;copies<br>  @&ensp;x&ensp;the&ensp;element&ensp;to&ensp;replicate</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.intersectBy"><code><a class="type" href="Data.List.html#Data.List.intersectBy"><span class="name function">intersectBy</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Compute&ensp;the&ensp;intersect&ensp;of&ensp;two&ensp;lists&ensp;by&ensp;user-supplied&ensp;equality&ensp;predicate.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.intersect"><code><a class="type" href="Data.List.html#Data.List.intersect"><span class="name function">intersect</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Compute&ensp;the&ensp;intersection&ensp;of&ensp;two&ensp;lists&ensp;according&ensp;to&ensp;the&ensp;`Eq`&ensp;implementation&ensp;for<br>  the&ensp;elements.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.intersectAllBy"><code><a class="type" href="Data.List.html#Data.List.intersectAllBy"><span class="name function">intersectAllBy</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Compute&ensp;the&ensp;intersect&ensp;of&ensp;all&ensp;the&ensp;lists&ensp;in&ensp;the&ensp;given&ensp;list&ensp;of&ensp;lists,&ensp;according<br>  to&ensp;the&ensp;user-supplied&ensp;equality&ensp;predicate.<br>  <br>  @&ensp;eq&ensp;the&ensp;predicate&ensp;for&ensp;computing&ensp;the&ensp;intersection<br>  @&ensp;ls&ensp;the&ensp;list&ensp;of&ensp;lists&ensp;to&ensp;compute&ensp;the&ensp;intersect&ensp;of</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.intersectAll"><code><a class="type" href="Data.List.html#Data.List.intersectAll"><span class="name function">intersectAll</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Compute&ensp;the&ensp;intersect&ensp;of&ensp;all&ensp;the&ensp;lists&ensp;in&ensp;the&ensp;given&ensp;list&ensp;of&ensp;lists,&ensp;according<br>  to&ensp;boolean&ensp;equality.&ensp;A&ensp;special&ensp;case&ensp;of&ensp;`intersectAllBy`,&ensp;using&ensp;`==`&ensp;as&ensp;the<br>  equality&ensp;predicate.<br>  <br>  @&ensp;ls&ensp;the&ensp;list&ensp;of&ensp;lists&ensp;to&ensp;compute&ensp;the&ensp;intersect&ensp;of</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.NonEmpty"><code><span class="keyword">data</span>&ensp;<a class="type" href="Data.List.html#Data.List.NonEmpty"><span class="name type">NonEmpty</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Proof&ensp;that&ensp;a&ensp;given&ensp;list&ensp;is&ensp;non-empty.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Data.List.IsNonEmpty"><code><a class="type" href="Data.List.html#Data.List.IsNonEmpty"><span class="name constructor">IsNonEmpty</span></a>&ensp;:&ensp;<a class="type" href="Data.List.html#Data.List.NonEmpty"><span class="name type">NonEmpty</span></a>&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">xs</span>)</code></dt></dl><br>  <b>Hint</b>:&ensp;<dl class="decls"><dt id="$resolved4329"><code><span class="type resolved" title="Prelude.Uninhabited.Uninhabited"><span class="name type">Uninhabited</span></span>&ensp;(<a class="type" href="Data.List.html#Data.List.NonEmpty"><span class="name type">NonEmpty</span></a>&ensp;[])</code></dt></dl></dd><dt id="Data.List.head"><code><a class="type" href="Data.List.html#Data.List.head"><span class="name function">head</span></a>&ensp;:&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Data.List.html#Data.List.NonEmpty"><span class="name type">NonEmpty</span></a>&ensp;<span class="boundvar">l</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Get&ensp;the&ensp;head&ensp;of&ensp;a&ensp;non-empty&ensp;list.<br>  @&ensp;ok&ensp;proof&ensp;the&ensp;list&ensp;is&ensp;non-empty</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.tail"><code><a class="type" href="Data.List.html#Data.List.tail"><span class="name function">tail</span></a>&ensp;:&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Data.List.html#Data.List.NonEmpty"><span class="name type">NonEmpty</span></a>&ensp;<span class="boundvar">l</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Get&ensp;the&ensp;tail&ensp;of&ensp;a&ensp;non-empty&ensp;list.<br>  @&ensp;ok&ensp;proof&ensp;the&ensp;list&ensp;is&ensp;non-empty</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.last"><code><a class="type" href="Data.List.html#Data.List.last"><span class="name function">last</span></a>&ensp;:&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Data.List.html#Data.List.NonEmpty"><span class="name type">NonEmpty</span></a>&ensp;<span class="boundvar">l</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Retrieve&ensp;the&ensp;last&ensp;element&ensp;of&ensp;a&ensp;non-empty&ensp;list.<br>  @&ensp;ok&ensp;proof&ensp;that&ensp;the&ensp;list&ensp;is&ensp;non-empty</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.init"><code><a class="type" href="Data.List.html#Data.List.init"><span class="name function">init</span></a>&ensp;:&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Data.List.html#Data.List.NonEmpty"><span class="name type">NonEmpty</span></a>&ensp;<span class="boundvar">l</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Return&ensp;all&ensp;but&ensp;the&ensp;last&ensp;element&ensp;of&ensp;a&ensp;non-empty&ensp;list.<br>  @&ensp;ok&ensp;proof&ensp;the&ensp;list&ensp;is&ensp;non-empty</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.head&apos;"><code><a class="type" href="Data.List.html#Data.List.head&apos;"><span class="name function">head&apos;</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Attempt&ensp;to&ensp;get&ensp;the&ensp;head&ensp;of&ensp;a&ensp;list.&ensp;If&ensp;the&ensp;list&ensp;is&ensp;empty,&ensp;return&ensp;`Nothing`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.tail&apos;"><code><a class="type" href="Data.List.html#Data.List.tail&apos;"><span class="name function">tail&apos;</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Attempt&ensp;to&ensp;get&ensp;the&ensp;tail&ensp;of&ensp;a&ensp;list.&ensp;If&ensp;the&ensp;list&ensp;is&ensp;empty,&ensp;return&ensp;`Nothing`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.last&apos;"><code><a class="type" href="Data.List.html#Data.List.last&apos;"><span class="name function">last&apos;</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Attempt&ensp;to&ensp;retrieve&ensp;the&ensp;last&ensp;element&ensp;of&ensp;a&ensp;non-empty&ensp;list.<br>  <br>  If&ensp;the&ensp;list&ensp;is&ensp;empty,&ensp;return&ensp;`Nothing`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.init&apos;"><code><a class="type" href="Data.List.html#Data.List.init&apos;"><span class="name function">init&apos;</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Attempt&ensp;to&ensp;return&ensp;all&ensp;but&ensp;the&ensp;last&ensp;element&ensp;of&ensp;a&ensp;non-empty&ensp;list.<br>  <br>  If&ensp;the&ensp;list&ensp;is&ensp;empty,&ensp;return&ensp;`Nothing`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.foldr1By"><code><a class="type" href="Data.List.html#Data.List.foldr1By"><span class="name function">foldr1By</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Data.List.html#Data.List.NonEmpty"><span class="name type">NonEmpty</span></a>&ensp;<span class="boundvar">l</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Foldr&ensp;a&ensp;non-empty&ensp;list,&ensp;using&ensp;`map`&ensp;to&ensp;transform&ensp;the&ensp;first&ensp;accumulated<br>  element&ensp;to&ensp;something&ensp;of&ensp;the&ensp;desired&ensp;type&ensp;and&ensp;`func`&ensp;to&ensp;accumulate&ensp;the<br>  elements.<br>  <br>  @&ensp;func&ensp;the&ensp;function&ensp;used&ensp;to&ensp;accumulate&ensp;the&ensp;elements<br>  @&ensp;map&ensp;an&ensp;initial&ensp;transformation&ensp;from&ensp;the&ensp;element&ensp;to&ensp;the&ensp;accumulated&ensp;type<br>  @&ensp;l&ensp;the&ensp;non-empty&ensp;list&ensp;to&ensp;foldr<br>  @&ensp;ok&ensp;proof&ensp;that&ensp;the&ensp;list&ensp;is&ensp;non-empty</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.foldl1By"><code><a class="type" href="Data.List.html#Data.List.foldl1By"><span class="name function">foldl1By</span></a>&ensp;:&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Data.List.html#Data.List.NonEmpty"><span class="name type">NonEmpty</span></a>&ensp;<span class="boundvar">l</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Foldl&ensp;a&ensp;non-empty&ensp;list,&ensp;using&ensp;`map`&ensp;to&ensp;transform&ensp;the&ensp;first&ensp;accumulated<br>  element&ensp;to&ensp;something&ensp;of&ensp;the&ensp;desired&ensp;type&ensp;and&ensp;`func`&ensp;to&ensp;accumulate&ensp;the<br>  elements.<br>  <br>  @&ensp;func&ensp;the&ensp;function&ensp;used&ensp;to&ensp;accumulate&ensp;the&ensp;elements<br>  @&ensp;map&ensp;an&ensp;initial&ensp;transformation&ensp;from&ensp;the&ensp;element&ensp;to&ensp;the&ensp;accumulated&ensp;type<br>  @&ensp;l&ensp;the&ensp;non-empty&ensp;list&ensp;to&ensp;foldl<br>  @&ensp;ok&ensp;proof&ensp;that&ensp;the&ensp;list&ensp;is&ensp;non-empty</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.foldr1"><code><a class="type" href="Data.List.html#Data.List.foldr1"><span class="name function">foldr1</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Data.List.html#Data.List.NonEmpty"><span class="name type">NonEmpty</span></a>&ensp;<span class="boundvar">l</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Foldr&ensp;a&ensp;non-empty&ensp;list&ensp;without&ensp;seeding&ensp;the&ensp;accumulator.<br>  <br>  @&ensp;ok&ensp;proof&ensp;that&ensp;the&ensp;list&ensp;is&ensp;non-empty</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.foldl1"><code><a class="type" href="Data.List.html#Data.List.foldl1"><span class="name function">foldl1</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Data.List.html#Data.List.NonEmpty"><span class="name type">NonEmpty</span></a>&ensp;<span class="boundvar">l</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Foldl&ensp;a&ensp;non-empty&ensp;list&ensp;without&ensp;seeding&ensp;the&ensp;accumulator.<br>  <br>  @&ensp;ok&ensp;proof&ensp;that&ensp;the&ensp;list&ensp;is&ensp;non-empty</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.toList1"><code><a class="type" href="Data.List.html#Data.List.toList1"><span class="name function">toList1</span></a>&ensp;:&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Data.List.html#Data.List.NonEmpty"><span class="name type">NonEmpty</span></a>&ensp;<span class="boundvar">l</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.List1.html#Data.List1.List1"><span class="name type">List1</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Convert&ensp;to&ensp;a&ensp;non-empty&ensp;list.<br>  <br>  @&ensp;ok&ensp;proof&ensp;the&ensp;list&ensp;is&ensp;non-empty</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.toList1&apos;"><code><a class="type" href="Data.List.html#Data.List.toList1&apos;"><span class="name function">toList1&apos;</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<a class="type" href="Data.List1.html#Data.List1.List1"><span class="name type">List1</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Convert&ensp;to&ensp;a&ensp;non-empty&ensp;list,&ensp;returning&ensp;Nothing&ensp;if&ensp;the&ensp;list&ensp;is&ensp;empty.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.interleave"><code><a class="type" href="Data.List.html#Data.List.interleave"><span class="name function">interleave</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Interleave&ensp;two&ensp;lists.<br>  ```idris&ensp;example<br>  >&ensp;interleave&ensp;[&quot;a&quot;,&ensp;&quot;c&quot;,&ensp;&quot;e&quot;]&ensp;[&quot;b&quot;,&ensp;&quot;d&quot;,&ensp;&quot;f&quot;]<br>  [&quot;a&quot;,&ensp;&quot;b&quot;,&ensp;&quot;c&quot;,&ensp;&quot;d&quot;,&ensp;&quot;e&quot;,&ensp;&quot;f&quot;]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.mergeReplicate"><code><a class="type" href="Data.List.html#Data.List.mergeReplicate"><span class="name function">mergeReplicate</span></a>&ensp;:&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Prefix&ensp;every&ensp;element&ensp;in&ensp;the&ensp;list&ensp;with&ensp;the&ensp;given&ensp;element.<br>  <br>  @&ensp;sep&ensp;the&ensp;value&ensp;to&ensp;prefix<br>  @&ensp;xs&ensp;the&ensp;list&ensp;of&ensp;elements&ensp;to&ensp;prefix&ensp;with&ensp;the&ensp;given&ensp;element<br>  <br>  ```idris&ensp;example<br>  >&ensp;with&ensp;List&ensp;(mergeReplicate&ensp;&apos;&gt;&apos;&ensp;[&apos;a&apos;,&ensp;&apos;b&apos;,&ensp;&apos;c&apos;,&ensp;&apos;d&apos;,&ensp;&apos;e&apos;])<br>  [&apos;&gt;&apos;,&ensp;&apos;a&apos;,&ensp;&apos;&gt;&apos;,&ensp;&apos;b&apos;,&ensp;&apos;&gt;&apos;,&ensp;&apos;c&apos;,&ensp;&apos;&gt;&apos;,&ensp;&apos;d&apos;,&ensp;&apos;&gt;&apos;,&ensp;&apos;e&apos;]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.intersperse"><code><a class="type" href="Data.List.html#Data.List.intersperse"><span class="name function">intersperse</span></a>&ensp;:&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Insert&ensp;some&ensp;separator&ensp;between&ensp;the&ensp;elements&ensp;of&ensp;a&ensp;list.<br>  <br>  @&ensp;sep&ensp;the&ensp;value&ensp;to&ensp;intersperse<br>  @&ensp;xs&ensp;the&ensp;list&ensp;of&ensp;elements&ensp;to&ensp;intersperse&ensp;with&ensp;the&ensp;separator<br>  <br>  ```idris&ensp;example<br>  >&ensp;with&ensp;List&ensp;(intersperse&ensp;&apos;,&apos;&ensp;[&apos;a&apos;,&ensp;&apos;b&apos;,&ensp;&apos;c&apos;,&ensp;&apos;d&apos;,&ensp;&apos;e&apos;])<br>  [&apos;a&apos;,&ensp;&apos;,&apos;,&ensp;&apos;b&apos;,&ensp;&apos;,&apos;,&ensp;&apos;c&apos;,&ensp;&apos;,&apos;,&ensp;&apos;d&apos;,&ensp;&apos;,&apos;,&ensp;&apos;e&apos;]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.intercalate"><code><a class="type" href="Data.List.html#Data.List.intercalate"><span class="name function">intercalate</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Given&ensp;a&ensp;separator&ensp;list&ensp;and&ensp;some&ensp;more&ensp;lists,&ensp;produce&ensp;a&ensp;new&ensp;list&ensp;by<br>  placing&ensp;the&ensp;separator&ensp;between&ensp;each&ensp;of&ensp;the&ensp;lists.<br>  <br>  @&ensp;sep&ensp;the&ensp;separator<br>  @&ensp;xss&ensp;the&ensp;lists&ensp;between&ensp;which&ensp;the&ensp;separator&ensp;will&ensp;be&ensp;placed<br>  <br>  ```idris&ensp;example<br>  intercalate&ensp;[0,&ensp;0,&ensp;0]&ensp;[&ensp;[1,&ensp;2,&ensp;3],&ensp;[4,&ensp;5,&ensp;6],&ensp;[7,&ensp;8,&ensp;9]&ensp;]<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.catMaybes"><code><a class="type" href="Data.List.html#Data.List.catMaybes"><span class="name function">catMaybes</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Extract&ensp;all&ensp;of&ensp;the&ensp;values&ensp;contained&ensp;in&ensp;a&ensp;List&ensp;of&ensp;Maybes</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.sorted"><code><a class="type" href="Data.List.html#Data.List.sorted"><span class="name function">sorted</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Check&ensp;whether&ensp;a&ensp;list&ensp;is&ensp;sorted&ensp;with&ensp;respect&ensp;to&ensp;the&ensp;default&ensp;ordering&ensp;for&ensp;the&ensp;type&ensp;of&ensp;its&ensp;elements.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.mergeBy"><code><a class="type" href="Data.List.html#Data.List.mergeBy"><span class="name function">mergeBy</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ordering"><span class="name type">Ordering</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Merge&ensp;two&ensp;sorted&ensp;lists&ensp;using&ensp;an&ensp;arbitrary&ensp;comparison<br>  predicate.&ensp;Note&ensp;that&ensp;the&ensp;lists&ensp;must&ensp;have&ensp;been&ensp;sorted&ensp;using&ensp;this<br>  predicate&ensp;already.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.merge"><code><a class="type" href="Data.List.html#Data.List.merge"><span class="name function">merge</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Merge&ensp;two&ensp;sorted&ensp;lists&ensp;using&ensp;the&ensp;default&ensp;ordering&ensp;for&ensp;the&ensp;type&ensp;of&ensp;their&ensp;elements.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.sortBy"><code><a class="type" href="Data.List.html#Data.List.sortBy"><span class="name function">sortBy</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ordering"><span class="name type">Ordering</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Sort&ensp;a&ensp;list&ensp;using&ensp;some&ensp;arbitrary&ensp;comparison&ensp;predicate.<br>  <br>  @&ensp;cmp&ensp;how&ensp;to&ensp;compare&ensp;elements<br>  @&ensp;xs&ensp;the&ensp;list&ensp;to&ensp;sort</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.sort"><code><a class="type" href="Data.List.html#Data.List.sort"><span class="name function">sort</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Sort&ensp;a&ensp;list&ensp;using&ensp;the&ensp;default&ensp;ordering&ensp;for&ensp;the&ensp;type&ensp;of&ensp;its&ensp;elements.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.prefixOfBy"><code><a class="type" href="Data.List.html#Data.List.prefixOfBy"><span class="name function">prefixOfBy</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">m</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">m</span>,&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">b</span>)</code></dt><dd><pre>  Check&ensp;whether&ensp;the&ensp;`left`&ensp;list&ensp;is&ensp;a&ensp;prefix&ensp;of&ensp;the&ensp;`right`&ensp;one,&ensp;according&ensp;to<br>  `match`.&ensp;Returns&ensp;the&ensp;matched&ensp;prefix&ensp;together&ensp;with&ensp;the&ensp;leftover&ensp;suffix.<br>  <br>  @&ensp;match&ensp;a&ensp;custom&ensp;matching&ensp;function&ensp;for&ensp;checking&ensp;the&ensp;elements&ensp;are&ensp;convertible<br>  @&ensp;left&ensp;the&ensp;list&ensp;which&ensp;might&ensp;be&ensp;a&ensp;prefix&ensp;of&ensp;`right`<br>  @&ensp;right&ensp;the&ensp;list&ensp;of&ensp;elements&ensp;to&ensp;compare&ensp;against</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.isPrefixOfBy"><code><a class="type" href="Data.List.html#Data.List.isPrefixOfBy"><span class="name function">isPrefixOfBy</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Check&ensp;whether&ensp;the&ensp;`left`&ensp;list&ensp;is&ensp;a&ensp;prefix&ensp;of&ensp;the&ensp;`right`&ensp;one,&ensp;using&ensp;the<br>  provided&ensp;equality&ensp;function&ensp;to&ensp;compare&ensp;elements.<br>  <br>  @&ensp;eq&ensp;a&ensp;custom&ensp;equality&ensp;function&ensp;for&ensp;comparing&ensp;the&ensp;elements<br>  @&ensp;left&ensp;the&ensp;list&ensp;which&ensp;might&ensp;be&ensp;a&ensp;prefix&ensp;of&ensp;`right`<br>  @&ensp;right&ensp;the&ensp;list&ensp;of&ensp;elements&ensp;to&ensp;compare&ensp;againts</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.isPrefixOf"><code><a class="type" href="Data.List.html#Data.List.isPrefixOf"><span class="name function">isPrefixOf</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  The&ensp;isPrefixOf&ensp;function&ensp;takes&ensp;two&ensp;lists&ensp;and&ensp;returns&ensp;True&ensp;iff&ensp;the&ensp;first&ensp;list<br>  is&ensp;a&ensp;prefix&ensp;of&ensp;the&ensp;second&ensp;when&ensp;comparing&ensp;elements&ensp;using&ensp;`==`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.suffixOfBy"><code><a class="type" href="Data.List.html#Data.List.suffixOfBy"><span class="name function">suffixOfBy</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">m</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">b</span>,&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">m</span>)</code></dt><dd><pre>  Check&ensp;whether&ensp;the&ensp;`left`&ensp;is&ensp;a&ensp;suffix&ensp;of&ensp;the&ensp;`right`&ensp;one,&ensp;according&ensp;to<br>  `match`.&ensp;Returns&ensp;the&ensp;matched&ensp;suffix&ensp;together&ensp;with&ensp;the&ensp;leftover&ensp;prefix.<br>  <br>  @&ensp;match&ensp;a&ensp;custom&ensp;matching&ensp;function&ensp;for&ensp;checking&ensp;the&ensp;elements&ensp;are&ensp;convertible<br>  @&ensp;left&ensp;the&ensp;list&ensp;which&ensp;might&ensp;be&ensp;a&ensp;prefix&ensp;of&ensp;`right`<br>  @&ensp;right&ensp;the&ensp;list&ensp;of&ensp;elements&ensp;to&ensp;compare&ensp;against</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.isSuffixOfBy"><code><a class="type" href="Data.List.html#Data.List.isSuffixOfBy"><span class="name function">isSuffixOfBy</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Check&ensp;whether&ensp;the&ensp;`left`&ensp;is&ensp;a&ensp;suffix&ensp;of&ensp;the&ensp;`right`&ensp;one,&ensp;using&ensp;the&ensp;provided<br>  equality&ensp;function&ensp;to&ensp;compare&ensp;elements.<br>  <br>  @&ensp;eq&ensp;a&ensp;custom&ensp;equality&ensp;function&ensp;for&ensp;comparing&ensp;the&ensp;elements<br>  @&ensp;left&ensp;the&ensp;list&ensp;which&ensp;might&ensp;be&ensp;a&ensp;suffix&ensp;of&ensp;`right`<br>  @&ensp;right&ensp;the&ensp;list&ensp;of&ensp;elements&ensp;to&ensp;compare&ensp;againts</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.isSuffixOf"><code><a class="type" href="Data.List.html#Data.List.isSuffixOf"><span class="name function">isSuffixOf</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  The&ensp;isSuffixOf&ensp;function&ensp;takes&ensp;two&ensp;lists&ensp;and&ensp;returns&ensp;True&ensp;iff&ensp;the&ensp;first&ensp;list<br>  is&ensp;a&ensp;suffix&ensp;of&ensp;the&ensp;second&ensp;when&ensp;comparing&ensp;elements&ensp;using&ensp;`==`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.isInfixOf"><code><a class="type" href="Data.List.html#Data.List.isInfixOf"><span class="name function">isInfixOf</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  The&ensp;isInfixOf&ensp;function&ensp;takes&ensp;two&ensp;lists&ensp;and&ensp;returns&ensp;True&ensp;iff&ensp;the&ensp;first&ensp;list<br>  is&ensp;contained,&ensp;wholly&ensp;and&ensp;intact,&ensp;anywhere&ensp;within&ensp;the&ensp;second.<br>  <br>  ```idris&ensp;example<br>  isInfixOf&ensp;[&apos;b&apos;,&apos;c&apos;]&ensp;[&apos;a&apos;,&ensp;&apos;b&apos;,&ensp;&apos;c&apos;,&ensp;&apos;d&apos;]<br>  ```<br>  ```idris&ensp;example<br>  isInfixOf&ensp;[&apos;b&apos;,&apos;d&apos;]&ensp;[&apos;a&apos;,&ensp;&apos;b&apos;,&ensp;&apos;c&apos;,&ensp;&apos;d&apos;]<br>  ```<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.transpose"><code><a class="type" href="Data.List.html#Data.List.transpose"><span class="name function">transpose</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Transposes&ensp;rows&ensp;and&ensp;columns&ensp;of&ensp;a&ensp;list&ensp;of&ensp;lists.<br>  <br>  ```idris&ensp;example<br>  with&ensp;List&ensp;transpose&ensp;[[1,&ensp;2],&ensp;[3,&ensp;4]]<br>  ```<br>  <br>  This&ensp;also&ensp;works&ensp;for&ensp;non&ensp;square&ensp;scenarios,&ensp;thus<br>  involution&ensp;does&ensp;not&ensp;always&ensp;hold:<br>  <br>  transpose&ensp;[[],&ensp;[1,&ensp;2]]&ensp;=&ensp;[[1],&ensp;[2]]<br>  transpose&ensp;(transpose&ensp;[[],&ensp;[1,&ensp;2]])&ensp;=&ensp;[[1,&ensp;2]]</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.groupBy"><code><a class="type" href="Data.List.html#Data.List.groupBy"><span class="name function">groupBy</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<a class="type" href="Data.List1.html#Data.List1.List1"><span class="name type">List1</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  `groupBy`&ensp;operates&ensp;like&ensp;`group`,&ensp;but&ensp;uses&ensp;the&ensp;provided&ensp;equality<br>  predicate&ensp;instead&ensp;of&ensp;`==`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.group"><code><a class="type" href="Data.List.html#Data.List.group"><span class="name function">group</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<a class="type" href="Data.List1.html#Data.List1.List1"><span class="name type">List1</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  The&ensp;`group`&ensp;function&ensp;takes&ensp;a&ensp;list&ensp;of&ensp;values&ensp;and&ensp;returns&ensp;a&ensp;list&ensp;of<br>  lists&ensp;such&ensp;that&ensp;flattening&ensp;the&ensp;resulting&ensp;list&ensp;is&ensp;equal&ensp;to&ensp;the<br>  argument.&ensp;Moreover,&ensp;each&ensp;list&ensp;in&ensp;the&ensp;resulting&ensp;list<br>  contains&ensp;only&ensp;equal&ensp;elements.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.groupWith"><code><a class="type" href="Data.List.html#Data.List.groupWith"><span class="name function">groupWith</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<a class="type" href="Data.List1.html#Data.List1.List1"><span class="name type">List1</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  `groupWith`&ensp;operates&ensp;like&ensp;`group`,&ensp;but&ensp;uses&ensp;the&ensp;provided&ensp;projection&ensp;when<br>  comparing&ensp;for&ensp;equality</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.groupAllWith"><code><a class="type" href="Data.List.html#Data.List.groupAllWith"><span class="name function">groupAllWith</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<a class="type" href="Data.List1.html#Data.List1.List1"><span class="name type">List1</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  `groupAllWith`&ensp;operates&ensp;like&ensp;`groupWith`,&ensp;but&ensp;sorts&ensp;the&ensp;list<br>  first&ensp;so&ensp;that&ensp;each&ensp;equivalence&ensp;class&ensp;has,&ensp;at&ensp;most,&ensp;one&ensp;list&ensp;in&ensp;the<br>  output</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.List.consInjective"><code><a class="type" href="Data.List.html#Data.List.consInjective"><span class="name function">consInjective</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.the"><span class="name function">the</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">xs</span>)&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Basics.the"><span class="name function">the</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">b</span>)&ensp;(<span class="boundvar">y</span>&ensp;<span class="type resolved" title="Prelude.Basics.::"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">ys</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">x</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">y</span>,&ensp;<span class="boundvar">xs</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">ys</span>)</code></dt><dd><pre>  Heterogeneous&ensp;injectivity&ensp;for&ensp;(::)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.reverseInvolutive"><code><a class="type" href="Data.List.html#Data.List.reverseInvolutive"><span class="name function">reverseInvolutive</span></a>&ensp;:&ensp;(<span class="boundvar">xs</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.List.reverse"><span class="name function">reverse</span></span>&ensp;(<span class="type resolved" title="Prelude.Types.List.reverse"><span class="name function">reverse</span></span>&ensp;<span class="boundvar">xs</span>)&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">xs</span></code></dt><dd><pre>  List&ensp;`reverse`&ensp;applied&ensp;twice&ensp;yields&ensp;the&ensp;identity&ensp;function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.appendNilRightNeutral"><code><a class="type" href="Data.List.html#Data.List.appendNilRightNeutral"><span class="name function">appendNilRightNeutral</span></a>&ensp;:&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="type resolved" title="Prelude.Types.List.++"><span class="name function">++</span></span>&ensp;[]&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">l</span></code></dt><dd><pre>  The&ensp;empty&ensp;list&ensp;is&ensp;a&ensp;right&ensp;identity&ensp;for&ensp;append.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.appendAssociative"><code><a class="type" href="Data.List.html#Data.List.appendAssociative"><span class="name function">appendAssociative</span></a>&ensp;:&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">c</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">r</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="type resolved" title="Prelude.Types.List.++"><span class="name function">++</span></span>&ensp;(<span class="boundvar">c</span>&ensp;<span class="type resolved" title="Prelude.Types.List.++"><span class="name function">++</span></span>&ensp;<span class="boundvar">r</span>)&ensp;<span class="keyword">=</span>&ensp;(<span class="boundvar">l</span>&ensp;<span class="type resolved" title="Prelude.Types.List.++"><span class="name function">++</span></span>&ensp;<span class="boundvar">c</span>)&ensp;<span class="type resolved" title="Prelude.Types.List.++"><span class="name function">++</span></span>&ensp;<span class="boundvar">r</span></code></dt><dd><pre>  Appending&ensp;lists&ensp;is&ensp;associative.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.revAppend"><code><a class="type" href="Data.List.html#Data.List.revAppend"><span class="name function">revAppend</span></a>&ensp;:&ensp;(<span class="boundvar">vs</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">ns</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.List.reverse"><span class="name function">reverse</span></span>&ensp;<span class="boundvar">ns</span>&ensp;<span class="type resolved" title="Prelude.Types.List.++"><span class="name function">++</span></span>&ensp;<span class="type resolved" title="Prelude.Types.List.reverse"><span class="name function">reverse</span></span>&ensp;<span class="boundvar">vs</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Types.List.reverse"><span class="name function">reverse</span></span>&ensp;(<span class="boundvar">vs</span>&ensp;<span class="type resolved" title="Prelude.Types.List.++"><span class="name function">++</span></span>&ensp;<span class="boundvar">ns</span>)</code></dt><dd><pre>  `reverse`&ensp;is&ensp;distributive</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.dropFusion"><code><a class="type" href="Data.List.html#Data.List.dropFusion"><span class="name function">dropFusion</span></a>&ensp;:&ensp;(<span class="boundvar">n</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">m</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">t</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.List.html#Data.List.drop"><span class="name function">drop</span></a>&ensp;<span class="boundvar">n</span>&ensp;(<a class="type" href="Data.List.html#Data.List.drop"><span class="name function">drop</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">l</span>)&ensp;<span class="keyword">=</span>&ensp;<a class="type" href="Data.List.html#Data.List.drop"><span class="name function">drop</span></a>&ensp;(<span class="boundvar">n</span>&ensp;<span class="type resolved" title="Prelude.Num.+"><span class="name function">+</span></span>&ensp;<span class="boundvar">m</span>)&ensp;<span class="boundvar">l</span></code></dt><dd><pre>  Dropping&ensp;`m`&ensp;elements&ensp;from&ensp;`l`&ensp;and&ensp;then&ensp;dropping&ensp;`n`&ensp;elements&ensp;from&ensp;the<br>  result,&ensp;is&ensp;the&ensp;same&ensp;as&ensp;simply&ensp;dropping&ensp;`n+m`&ensp;elements&ensp;from&ensp;`l`</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.lengthMap"><code><a class="type" href="Data.List.html#Data.List.lengthMap"><span class="name function">lengthMap</span></a>&ensp;:&ensp;(<span class="boundvar">xs</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;(<span class="type resolved" title="Prelude.Interfaces.map"><span class="name function">map</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">xs</span>)&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">xs</span></code></dt><dd><pre>  Mapping&ensp;a&ensp;function&ensp;over&ensp;a&ensp;list&ensp;does&ensp;not&ensp;change&ensp;the&ensp;length&ensp;of&ensp;the&ensp;list.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.lengthReplicate"><code><a class="type" href="Data.List.html#Data.List.lengthReplicate"><span class="name function">lengthReplicate</span></a>&ensp;:&ensp;(<span class="boundvar">n</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.List.length"><span class="name function">length</span></span>&ensp;(<a class="type" href="Data.List.html#Data.List.replicate"><span class="name function">replicate</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">x</span>)&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">n</span></code></dt><dd><pre>  Proof&ensp;that&ensp;replicate&ensp;produces&ensp;a&ensp;list&ensp;of&ensp;the&ensp;requested&ensp;length.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.foldlAppend"><code><a class="type" href="Data.List.html#Data.List.foldlAppend"><span class="name function">foldlAppend</span></a>&ensp;:&ensp;(<span class="boundvar">f</span>&ensp;:&ensp;(<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">init</span>&ensp;:&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">xs</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">ys</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.foldl"><span class="name function">foldl</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">init</span>&ensp;(<span class="boundvar">xs</span>&ensp;<span class="type resolved" title="Prelude.Types.List.++"><span class="name function">++</span></span>&ensp;<span class="boundvar">ys</span>)&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.foldl"><span class="name function">foldl</span></span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="type resolved" title="Prelude.Interfaces.foldl"><span class="name function">foldl</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">init</span>&ensp;<span class="boundvar">xs</span>)&ensp;<span class="boundvar">ys</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.filterAppend"><code><a class="type" href="Data.List.html#Data.List.filterAppend"><span class="name function">filterAppend</span></a>&ensp;:&ensp;(<span class="boundvar">f</span>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">xs</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">ys</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.List.filter"><span class="name function">filter</span></span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">xs</span>&ensp;<span class="type resolved" title="Prelude.Types.List.++"><span class="name function">++</span></span>&ensp;<span class="boundvar">ys</span>)&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Types.List.filter"><span class="name function">filter</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">xs</span>&ensp;<span class="type resolved" title="Prelude.Types.List.++"><span class="name function">++</span></span>&ensp;<span class="type resolved" title="Prelude.Types.List.filter"><span class="name function">filter</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ys</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.mapMaybeFusion"><code><a class="type" href="Data.List.html#Data.List.mapMaybeFusion"><span class="name function">mapMaybeFusion</span></a>&ensp;:&ensp;(<span class="boundvar">g</span>&ensp;:&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">c</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">b</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">xs</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.List.mapMaybe"><span class="name function">mapMaybe</span></span>&ensp;<span class="boundvar">g</span>&ensp;(<span class="type resolved" title="Prelude.Types.List.mapMaybe"><span class="name function">mapMaybe</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">xs</span>)&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Types.List.mapMaybe"><span class="name function">mapMaybe</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.&gt;=&gt;"><span class="name function">&gt;=&gt;</span></span>&ensp;<span class="boundvar">g</span>)&ensp;<span class="boundvar">xs</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.mapMaybeAppend"><code><a class="type" href="Data.List.html#Data.List.mapMaybeAppend"><span class="name function">mapMaybeAppend</span></a>&ensp;:&ensp;(<span class="boundvar">f</span>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">b</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">xs</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">ys</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.List.mapMaybe"><span class="name function">mapMaybe</span></span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">xs</span>&ensp;<span class="type resolved" title="Prelude.Types.List.++"><span class="name function">++</span></span>&ensp;<span class="boundvar">ys</span>)&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Types.List.mapMaybe"><span class="name function">mapMaybe</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">xs</span>&ensp;<span class="type resolved" title="Prelude.Types.List.++"><span class="name function">++</span></span>&ensp;<span class="type resolved" title="Prelude.Types.List.mapMaybe"><span class="name function">mapMaybe</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ys</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.mapFusion"><code><a class="type" href="Data.List.html#Data.List.mapFusion"><span class="name function">mapFusion</span></a>&ensp;:&ensp;(<span class="boundvar">g</span>&ensp;:&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">c</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">xs</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.map"><span class="name function">map</span></span>&ensp;<span class="boundvar">g</span>&ensp;(<span class="type resolved" title="Prelude.Interfaces.map"><span class="name function">map</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">xs</span>)&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.map"><span class="name function">map</span></span>&ensp;(<span class="boundvar">g</span>&ensp;<span class="type resolved" title="Prelude.Basics.."><span class="name function">.</span></span>&ensp;<span class="boundvar">f</span>)&ensp;<span class="boundvar">xs</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.List.mapAppend"><code><a class="type" href="Data.List.html#Data.List.mapAppend"><span class="name function">mapAppend</span></a>&ensp;:&ensp;(<span class="boundvar">f</span>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">xs</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">ys</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.map"><span class="name function">map</span></span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="boundvar">xs</span>&ensp;<span class="type resolved" title="Prelude.Types.List.++"><span class="name function">++</span></span>&ensp;<span class="boundvar">ys</span>)&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.map"><span class="name function">map</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">xs</span>&ensp;<span class="type resolved" title="Prelude.Types.List.++"><span class="name function">++</span></span>&ensp;<span class="type resolved" title="Prelude.Interfaces.map"><span class="name function">map</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ys</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.5.1-c2dd824c5</footer></body></html>