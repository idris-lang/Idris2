<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>System.Concurrency</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : System.Concurrency
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>System.Concurrency<span style="float:right">(<a href="../source/System.Concurrency.html">source</a>)</span></h1><pre>Concurrency primitives, e.g. threads, mutexes, etc.

N.B.: At the moment this is pretty fundamentally tied to the Scheme RTS.
Given that different back ends will have entirely different threading
models, it might be unavoidable, but we might want to think about possible
primitives that back ends should support.
</pre></div><code></code><h2>Definitions</h2><dl class="decls"><dt id="System.Concurrency.setThreadData"><code><a class="type" href="System.Concurrency.html#System.Concurrency.setThreadData"><span class="name function">setThreadData</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;()</code></dt><dd><pre>  Set the data stored in a thread&apos;s parameter to the given value.<br>  Currently only supported under the scheme backends.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.getThreadData"><code><a class="type" href="System.Concurrency.html#System.Concurrency.getThreadData"><span class="name function">getThreadData</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Get the data stored in a thread&apos;s parameter.<br>  Currently only supported under the scheme backends.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.getThreadId"><code><a class="type" href="System.Concurrency.html#System.Concurrency.getThreadId"><span class="name function">getThreadId</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;<span class="name type">Int</span></code></dt><dd><pre>  Get the thread id of the current thread (chez backend).</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.Mutex"><code><span class="keyword">data</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Mutex"><span class="name type">Mutex</span></a>&ensp;:&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.makeMutex"><code><a class="type" href="System.Concurrency.html#System.Concurrency.makeMutex"><span class="name function">makeMutex</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Mutex"><span class="name type">Mutex</span></a></code></dt><dd><pre>  Creates and returns a new mutex.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.mutexAcquire"><code><a class="type" href="System.Concurrency.html#System.Concurrency.mutexAcquire"><span class="name function">mutexAcquire</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Mutex"><span class="name type">Mutex</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;()</code></dt><dd><pre>  Acquires the mutex identified by `mutex`. The thread blocks until the mutex<br>  has been acquired.<br>  <br>  Mutexes are recursive in Posix threads terminology, which means that the<br>  calling thread can use mutex-acquire to (re)acquire a mutex it already has.<br>  In this case, an equal number of mutex-release calls is necessary to release<br>  the mutex.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.mutexRelease"><code><a class="type" href="System.Concurrency.html#System.Concurrency.mutexRelease"><span class="name function">mutexRelease</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Mutex"><span class="name type">Mutex</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;()</code></dt><dd><pre>  Releases the mutex identified by `mutex`. Unpredictable behavior results if<br>  the mutex is not owned by the calling thread.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.Condition"><code><span class="keyword">data</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Condition"><span class="name type">Condition</span></a>&ensp;:&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.makeCondition"><code><a class="type" href="System.Concurrency.html#System.Concurrency.makeCondition"><span class="name function">makeCondition</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Condition"><span class="name type">Condition</span></a></code></dt><dd><pre>  Creates and returns a new condition variable.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.conditionWait"><code><a class="type" href="System.Concurrency.html#System.Concurrency.conditionWait"><span class="name function">conditionWait</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Condition"><span class="name type">Condition</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Mutex"><span class="name type">Mutex</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;()</code></dt><dd><pre>  Waits up to the specified timeout for the condition identified by the<br>  condition variable `cond`. The calling thread must have acquired the mutex<br>  identified by `mutex` at the time `conditionWait` is called. The mutex is<br>  released as a side effect of the call to `conditionWait`. When a thread is<br>  later released from the condition variable by one of the procedures<br>  described below, the mutex is reacquired and `conditionWait` returns.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.conditionWaitTimeout"><code><a class="type" href="System.Concurrency.html#System.Concurrency.conditionWaitTimeout"><span class="name function">conditionWaitTimeout</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Condition"><span class="name type">Condition</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Mutex"><span class="name type">Mutex</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Int</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;()</code></dt><dd><pre>  Variant of `conditionWait` with a timeout in microseconds.<br>  When the timeout expires, the thread is released, `mutex` is reacquired, and<br>  `conditionWaitTimeout` returns.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.conditionSignal"><code><a class="type" href="System.Concurrency.html#System.Concurrency.conditionSignal"><span class="name function">conditionSignal</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Condition"><span class="name type">Condition</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;()</code></dt><dd><pre>  Releases one of the threads waiting for the condition identified by `cond`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.conditionBroadcast"><code><a class="type" href="System.Concurrency.html#System.Concurrency.conditionBroadcast"><span class="name function">conditionBroadcast</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Condition"><span class="name type">Condition</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;()</code></dt><dd><pre>  Releases all of the threads waiting for the condition identified by `cond`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.Semaphore"><code><span class="keyword">data</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Semaphore"><span class="name type">Semaphore</span></a>&ensp;:&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.makeSemaphore"><code><a class="type" href="System.Concurrency.html#System.Concurrency.makeSemaphore"><span class="name function">makeSemaphore</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="name type">Int</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Semaphore"><span class="name type">Semaphore</span></a></code></dt><dd><pre>  Creates and returns a new semaphore with the counter initially set to `init`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.semaphorePost"><code><a class="type" href="System.Concurrency.html#System.Concurrency.semaphorePost"><span class="name function">semaphorePost</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Semaphore"><span class="name type">Semaphore</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;()</code></dt><dd><pre>  Increments the semaphore&apos;s internal counter.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.semaphoreWait"><code><a class="type" href="System.Concurrency.html#System.Concurrency.semaphoreWait"><span class="name function">semaphoreWait</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Semaphore"><span class="name type">Semaphore</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;()</code></dt><dd><pre>  Blocks until the internal counter for semaphore sema is non-zero. When the<br>  counter is non-zero, it is decremented and `semaphoreWait` returns.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.Barrier"><code><span class="keyword">data</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Barrier"><span class="name type">Barrier</span></a>&ensp;:&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A barrier enables multiple threads to synchronize the beginning of some<br>  computation.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.makeBarrier"><code><a class="type" href="System.Concurrency.html#System.Concurrency.makeBarrier"><span class="name function">makeBarrier</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="name type">Int</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Barrier"><span class="name type">Barrier</span></a></code></dt><dd><pre>  Creates a new barrier that can block a given number of threads.<br>  <br>  @ numThreads the number of threads to block</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.barrierWait"><code><a class="type" href="System.Concurrency.html#System.Concurrency.barrierWait"><span class="name function">barrierWait</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Barrier"><span class="name type">Barrier</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;()</code></dt><dd><pre>  Blocks the current thread until all threads have rendezvoused here.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.Channel"><code><span class="keyword">data</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Channel"><span class="name type">Channel</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.makeChannel"><code><a class="type" href="System.Concurrency.html#System.Concurrency.makeChannel"><span class="name function">makeChannel</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;(<a class="type" href="System.Concurrency.html#System.Concurrency.Channel"><span class="name type">Channel</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Creates and returns a new `Channel`.<br>  <br>  The channel can be used with `channelGet` to receive a value through the<br>  channel.<br>  The channel can be used with `channelPut` to send a value through the<br>  channel.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.channelGet"><code><a class="type" href="System.Concurrency.html#System.Concurrency.channelGet"><span class="name function">channelGet</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Channel"><span class="name type">Channel</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Blocks until a sender is ready to provide a value through `chan`. The result<br>  is the sent value.<br>  <br>  @ chan the channel to receive on</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.channelGetNonBlocking"><code><a class="type" href="System.Concurrency.html#System.Concurrency.channelGetNonBlocking"><span class="name function">channelGetNonBlocking</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Channel"><span class="name type">Channel</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;(<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Non-blocking version of channelGet (chez backend).<br>  <br>  @ chan the channel to receive on</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.channelGetWithTimeout"><code><a class="type" href="System.Concurrency.html#System.Concurrency.channelGetWithTimeout"><span class="name function">channelGetWithTimeout</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Channel"><span class="name type">Channel</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;(<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Timeout version of channelGet (chez backend).<br>  <br>  @ chan the channel to receive on<br>  @ milliseconds how many milliseconds to wait until timeout</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="System.Concurrency.channelPut"><code><a class="type" href="System.Concurrency.html#System.Concurrency.channelPut"><span class="name function">channelPut</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.IO.HasIO"><span class="name type">HasIO</span></span>&ensp;<span class="boundvar">io</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="System.Concurrency.html#System.Concurrency.Channel"><span class="name type">Channel</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">io</span>&ensp;()</code></dt><dd><pre>  Puts a value on the given channel.<br>  <br>  @ chan the `Channel` to send the value over<br>  @ val  the value to send</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.7.0-6c6ee58eb</footer></body></html>